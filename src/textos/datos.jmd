# Representando datos

```julia; echo=false; results="hidden"
import Weave
Weave.set_chunk_defaults(Dict{Symbol,Any}(:display=>true))
dirbase = pwd()
cd("../datos")
```

## Un ejemplo para empezar

En un uso productivo de un lenguaje de programación no nos limitamos a introducir datos con el teclado y leer los resultados en pantalla. Usamos series largas de datos, tablas numéricas... normalmente las leemos a partir de archivos de texto u hojas de cálculo. La salida también pueden ser archivos de ese tipo, o también gráficas (que veremos en el siguiente capítulo). Vamos a ver como se leen, escriben y estructuran esos datos.

Pongamos el siguiente caso. Tenemos un conjunto de datos extraidos de un experimento, consistente en 30 medidas con dos series de datos cada una, semejantes a las mostradas en la figura 1. Estos datos se encuentran grabados en los archivos de texto contenidos en XXXXXXXXXXXXX. [Comentar acceso.].

Cada uno de estos archivos tiene 100 líneas con tres columnas de datos separadas por tabuladores: la primera columna es una línea de tiempos equiespaciada que varía entre 0.01 y 1.00, y las otras dos columnas contienen las series de datos.

```julia; echo=false; results="hidden"
using DelimitedFiles, Plots
datos = readdlm("series/sA12.txt")
```
```julia; echo=false
plot(datos[:,1],datos[:,2:3],label=["x" "y"])
```

En todos los casos ambas series tienen una forma semejante, con un "valle" negativo seguido de un "pico" positivo. Supongamos que en el estudio que tenemos entre manos las dos series de datos identifican las coordenadas $(x,y)$ de un punto móvil, que se desplaza en torno a dos extremos (el "valle" y el "pico"); los dos puntos más alejados son los que corresponden con los máximos locales del módulo $m=\sqrt{x^2+y^2}$ (el primero para valores negativos de $x$, $y$, y el segundo para valores positivos. Nuestro propósito es generar una tabla de datos que contenga el intervalo de tiempo transcurrido entre esos dos extremos de la señal, la distancia entre esos dos puntos extremos y la proporción entre la distancia recorrida en $x$ y en $y$.

Para localizar los extremos calculamos un "módulo con signo" multiplicando el resultado de $m=\sqrt{x^2+y^2}$ por el signo de una de las dos coordenadas. De este modo, el valor mínimo (negativo) será el primer extremo, y el máximo (positivo) será el segundo extremo. El código para construir la tabla de datos, que iremos explicando a lo largo del capítulo, es el siguiente:

```julia; display=false
# Leemos los nombres de los archivos del directorio "series"
directorio = "series"
archivos = readdir(directorio)
# ¿Cuantos archivos tenemos?
n = length(archivos)
# Creamos dos vectores de números con tantos ceros como archivos hay:
# uno para los tiempos y otro para las distancias
intervalos = zeros(n)
distancias = zeros(n)
proporcionxy = zeros(n)
# Ahora vamos explorando los archivos uno a uno y rellenando datos
# Necesitaremos el módulo DelimitedFiles para poder leer los archivos
using DelimitedFiles
for i=1:n
    rutaarchivo = joinpath(directorio,archivos[i])
    # Leemos el contenido del archivo completo en la variable `datos`
    datos = readdlm(rutaarchivo)
    # Utilizamos `tiempo`, `x` e `y` para extraer las tres columnas de datos
    tiempo  = datos[:,1]
    x = datos[:,2]
    y = datos[:,3]
    # Calculamos el "módulo con signo" para localizar los extremos
    modulo = sign.(x) .* sqrt.(x.^2 + y.^2)
    (valor_minimo, indice_minimo) = findmin(modulo)
    (valor_maximo, indice_maximo) =  findmax(modulo)
    # Y asignamos los datos que corresponden a los intervalos y distancias
    intervalos[i] = tiempo[indice_maximo] - tiempo[indice_minimo]
    distancia_x = x[indice_maximo] - x[indice_minimo]
    distancia_y = y[indice_maximo] - y[indice_minimo]
    distancias[i] = sqrt(distancia_x^2 + distancia_y^2)
    proporcionxy[i] = distancia_y/distancia_x
end
# Para terminar escribimos los datos en una matriz con cuatro columnas:
# 1: el nombre del archivo
# 2: el intervalo entre extremos
# 3: la distancia entre extremos
# 4: la proporción entre la distancia en x e y
resultados = [archivos intervalos distancias proporcionxy]
```

Tomando este ejemplo como refencia, vamos a ver ahora algunos tipos y estructuras elementales de datos con las que normalmente trabajaremos en Julia.

## Números escalares y series de números

Cuando se habla de "datos" o "variables", lo más inmediato es pensar en números, que es también el tipo de datos para el que es más sencillo escribir instrucciones. Incluso para los principantes generalmente no hace falta dar demasiadas explicaciones: los nombres de las funciones y la sintaxis de las operaciones numéricas es común a muchos otros lenguajes de programación, y consisten esencialmente en una transposición a texto simple de las fórmulas matemáticas correspondientes a la operación que se desea realizar. En Julia este principio se lleva incluso más lejos que en otros lenguajes; por ejemplo:

  * Si `a` es el nombre de una variable, `2a` significa "2 veces `a`" (y lo mismo con cualquier otro número, sea entero, decimal o de otro tipo). Esto es posible gracias a que los nombres de variables no pueden comenzar por números, por lo que no hay ambigüedad posible. En otros lenguajes es obligatorio expresarlo como un producto explícito, es decir `2*a`.
  * Se pueden utilizar símbolos matemáticos de Unicode para representar algunos operadores matemáticos habituales que no están en el conjunto de caracteres ASCII: `≠` para "no es igual que" (equivalente a `!=` cuando se escribe solo con ASCII), o `≤` y `≥` para "menor que" y "mayor que", respectivamente (equivalentes a `<=`, `>=`). 
  * Es posible escribir comparaciones lógicas concatenadas, como `0 ≤ x ≤ 1` para comprobar si la variable `x` se encuentra entre `0` y `1`. (En otros lenguajes es necesario expresarlo de forma más compleja, como `(0 <= x) && (x <= 1)`.
  
Por otro lado, con mucha frecuencia las variables con las que interesa trabajar no representan números escalares, sino series organizadas de números o vectores. Esto ocurre con las siguientes variables del ejemplo anterior:

* `datos`: matrices de 100×3 que contienen los datos numéricos leídos directamente de los archivos.
* `tiempo`, `x`, `y`: vectores de 100 números con cada una de las tres columnas de `datos`.
* `modulo`: vectores de 100 números resultantes de operar con `x` e `y`.
* `intervalos`, `distancias` y `proporcionxy`: vectores de `n` elementos (30) que contienen los resultados que buscamos para cada uno de los archivos.

En Julia los vectores y matrices (junto con las "hipermatrices" de más de dos dimensiones) son casos específicos de *arrays*, que se pueden definir en general como conjuntos de datos ordenados (numéricos o también de otros tipos, como veremos después). Su manejo es un tema extenso, que se trata de forma más detallada en el capítulo XXXXXXXXXXXX. Por ahora, como introducción solo veremos superficialmente los vectores (*arrays* unidimensionales). En el ejemplo hemos leído los datos a partir de archivos grabados en disco, como es habitual, pero un vector también se puede definir "a mano" a partir del conjunto de datos que contiene, encerrados entre corchetes y separados por comas:

```julia; display=false
primos = [1,3,5,7,11,13,17]
```

Es posible extraer un valor concreto del vector, utilizando también los corchetes para señalar el "índice" que se quiere tomar. Estos índices pueden ser números enteros, o la palabra clave `end` para referirse al último elemento:

```julia
primos[3]
primos[end]
primos[end-1]
```

En el código del ejemplo, las expresiones `tiempo[indice_maximo]`, `tiempo[indice_minimo]` (y las equivalentes con los vectores `x`, `y` precisamente sirven para extraer el valor del vector correspondiente en los puntos donde se dan los valores extremos de `modulo`. (Los índices `indice_minimo`, `indice_maximo` se obtienen a través de las funciones `findmin` y `findmax`, respectivamente, aplicadas al vector `modulo`.)

También vemos en el ejemplo que cuando estas expresiones se ponen a la izquierda del símbolo `=` lo que se hace no es "leer" un valor del vector, sino asignarle el valor calculado en la parte derecha de la ecuación, como ocurre con `intervalos[i] = ...` y `distancias[i] = ...`. A la hora de modificar un vector hay que tener en cuenta dos restricciones importantes: solo se pueden incorporar datos del mismo tipo que el vector original, y no se puede "rebasar" el tamaño del vector original. Por ejemplo:

```julia; eval=false
numeros = [1,2,3,4,5,6]
numeros[1] = 0   # Esto no es problema
numeros[1] = 0.5 # Pero esto sí, porque eran números enteros
```
```
ERROR: InexactError: Int64(Int64, 0.5)
```
```julia; eval=false
numeros[7] = 10  # Esto también, porque el vector solo tenía 6 elementos
```
```
ERROR: BoundsError: attempt to access 6-element Array{Int64,1} at index [7]
```

La lectura y asignación de valores se puede hacer elemento a elemento, o también sobre varios elementos a la vez, utilizando un "vector de índices" para referirse a los elementos de interés. Para abreviar, un rango de índices correlativos se puede expresar como `a:b`, que significa "desde `a` hasta `b`. Por ejemplo:

```julia
# Dos alternativas para tomar los tres primeros números primos
primos[ [1,2,3] ]
primos[1:3]
```

Para referirse a "todos los elementos" puede utilizarse el rango `1:end` (es decir, "desde el primero hasta el final"), o de forma abreviada los dos puntos sin más (`:`). Esto se emplea a menudo cuando se trabaja con matrices, para referirse a "todas las filas" o "todas las columnas". Aunque las operaciones con matrices las veremos con más detalle en XXXXXXX, en el ejemplo anterior ya podemos observar esto, en las líneas donde se extraen las tres columnas de la matriz `datos`. Por ejemplo, `tiempo = datos[:,1]` expresa que a la variable `tiempo` le asignamos "todas las filas de la primera columna" de `datos`.

Finalmente, también se puede aplicar una misma operación a todos los elementos de un *array* a la vez. Podemos ver la diferencia entre las operaciones con escalares y *arrays* en las dos líneas del ejemplo donde se calcula el módulo de un segmento de dos coordenadas. Empezando por el final, en la línea:

```julia; eval=false
distancias[i] = sqrt(distancia_x^2 + distancia_y^2)
```

tenemos una operación realizada sobre dos números escalares (`distancia_x`, `distancia_y`), cuyo resultado se asigna a un elemento del vector `distancias`. Pero unas líneas antes tenemos una operación semejante aplicada a todos los elementos de los vectores `x` e `y`, dando como resultado otro vector de la misma longitud que se asigna a la variable `modulo`:

```julia; eval=false
modulo = sign.(x) .* sqrt.(x.^2 + y.^2)
```

Para hacer estos cálculos "elemento a elemento" (lo que se conoce como *vectorizar el código*), se ha añadido un punto tras los nombres de las funciones (`sign`, `sqrt`) y antes de los símbolos de los operadores (`*` para la multiplicación y `^` para la potencia). También podíamos haber tenido ya un vector `modulo` predefinido, de la longitud adecuada (100), y asignar los 100 resultados de la operación a cada uno de sus elementos, añadiendo el punto al símbolo de asignación (`=`):

```julia; eval=false
modulo .= sign.(x) .* sqrt.(x.^2 + y.^2)
```

(Esta alternativa sería de hecho más eficiente, porque no tendría que crearse el vector asignado a `modulo` las 30 veces que se repite el bucle, sino que se reutilizaría en cada repetición, aunque no funcionaría si cada archivo tuviese una longitud distinta.)

Como regla general, al vectorizar una operación todas las variables empleadas han de tener el mismo tamaño (como ocurre con `x` e `y`), pero estas variables también pueden combinarse con números escalares. En ese caso los números escalares operan por igual sobre todos los elementos de los otros vectores, como si se "expandieran" a vectores de la misma longitud con valores repetidos (lo que se conoce como *broadcasting*). Esto es lo que ocurre cuando `x` e `y` se elevan al cuadrado como `x.^2`, `y.^2` (usando un solo `2` escalar, en lugar de un vector de 100 números).

## Cadenas de texto y símbolos

Julia es un lenguaje pensado especialmente para trabajar con números, pero también tiene herramientas para manejar cadenas de texto (*strings*). Las cadenas de texto son un tipo de datos más, que al igual que los números pueden organizarse en *arrays*; así, los nombres de los 30 archivos tratados en el ejemplo anterior se agrupan en el vector de *strings* llamado `archivos`, de tal modo que el nombre del primer archivo es `archivos[1]`, etc.

Las cadenas de texto son esencialmente secuencias de letras que se presentan delimitadas por comillas dobles (`"`). En parte se pueden comparar a vectores de letras, ya que es posible extraer letras aisladas o partes del texto con la misma sintaxis que se utiliza con los *arrays*. Por ejemplo, supongamos que queremos extraer el nombre del archivo sin la extensión `.txt` del archivo que está en la posición `i` de la lista. Se trata de una operación que ya está programada en la función `splitext`; pero como la extensión que queremos eliminar tiene cuatro letras, se podría asignar el nombre sin extensión a la variable `sinextension` del siguiente modo:

```julia; echo=false; display=false
i = 1
```

```julia
nombrearchivo = archivos[i]
sinextension = nombrearchivo[1:end-4]
# O en una sola línea:
sinextension = archivos[i][1:end-4]
```

Si extraemos una sola letra, como el código `A` o `B` que aparece en segunda posición del nombre archivo, podemos ver cómo las letras individuales se delimitan con comillas simples (`'`), en lugar de las dobles usadas para las cadenas de texto:

```julia
codigo = nombrearchivo[2]
```

Sin embargo, al contrario que los *arrays* convencionales, las cadenas de texto son objetos "inmutables", y no es posible modificar sus letras de la misma manera que haríamos con los contenidos de un vector:

```julia; eval=false
nombrearchivo[2] = 'C'
```
```
ERROR: MethodError: no method matching setindex!(::String, ::Char, ::Int64)
```

Como alternativa hay múltipes funciones para manipular cadenas de texto, las más importantes de las cuales se comentan en el capítulo XXXXXXXXXXXXX dedicado a este tema. Pero hay una forma de componer cadenas de texto que es especialmente práctica y vale la pena adelantar: la "interpolación". Dada una variable `x`, sea numérica o literal, su contenido puede insertarse dentro de un texto utilizando el signo del dólar (`$`) para marcarla. También se puede interpolar una expresión más compleja encerrándola entre paréntesis:

```julia
x = 2
txt1 = "uno más uno es igual a $x"
txt2 = "y $x al cuadrado es $(x^2)"
```

El uso de `$` para interpolar datos en una cadena de texto impide que se pueda escribir tal cual, si lo que queremos es incluir ese signo en el texto. Para este y otros casos se utilizan "secuencias de escape", que generalmente comienzan con una barra invertida (`\`). Las secuencias de escape más útiles son:

  * `\$` para el signo del dólar.
  * `\\` para la barra invertida.
  * `\"` para las comillas dobles.
  * `\t` para el tabulador.
  * `\n` para el carácter de nueva línea.
  * `\r` para el carácter de "retorno de carro" (normalmente combinado como `\r\n` para definir una nueva línea en Windows).
  
Por ejemplo, para escribir la cadena de texto `j print("El símbolo del dólar es \"\$\"")` tendría utilizarse el código: `"El símbolo del dólar es \"\$\""`. 

!!! note

    El asunto de las secuencias de escape suele crear problemas en Windows, donde los directorios de una ruta suelen presentarse divididos por "barras invertidas". Por ejemplo, si quisiéramos cambiar el directorio de trabajo podría a `C:\julia`, la expresión `cd("C:\julia")` no daría el resultado esperado, porque la barra invertida se interpreta como inicio de una secuencia de escape. Para que funcionase, habría que escribir `cd("C:\\julia")`, o alternativamente `cd("C:/julia")`. La función `clipboard` y los diálogos de selección de archivos y directorios señalados en el capítulo anterior sortean correctamente este problema.


Finalmente haremos mención a un tipo especial de cadenas de texto, los *símbolos*: se trata de secuencias de caracteres alfanuméricos o signos que pueden representar nombres de variables, funciones u operadores, que se escriben precediéndolas de dos puntos (`:`) para distinguirlas de cadenas de texto convencionales. Los símbolos pueden referirse a operaciones o variables existentes como `:+`, `:log`, `:include`, o también inexistentes. Están particularmente pensados para procesos de [metaprogramación](XXXXXXXXXXXXXXXX), es decir para manipular y crear código programáticamente, que es una forma de uso particularmente avanzado de Julia, y que en esta guía solo trataremos superficialmente. Pero incluso en el uso cotidiano nos encontraremos de vez en cuando con este tipo de símbolos, como veremos a continuación, y por eso vale la pena introducirlos ahora.

## Matrices de datos

Además de los vectores (*arrays* unidimensionales), otra forma habitual de estructurar los datos es en forma de matrices (*arrays* de dos dimensiones, con filas y columnas), como las matrices numéricas que en el ejemplo se asignan a la variable `datos`, así como la matriz que se genera al final, `resultados`, que contiene los siguientes valores:

```julia; echo=false
resultados
```

Esta matriz no es puramente numérica ni de cadenas de texto, sino que combina ambos tipos de datos, usando un "supertipo" llamado `Any` que engloba todo tipo de objetos definidos en Julia.

A menudo, como ocurre con los datos de entrada en el ejemplo anterior, estas matrices se crean leyendo archivos de texto. La forma más directa de hacerlo es mediante la función `readdlm` del módulo estándar `DelimitedFiles`, que en principio interpreta el archivo como una matriz en la que cada línea de texto representa una fila de datos, con columnas delimitadas por uno o más caracteres de separación (espacios en blanco o tabuladores). Los espacios dentro de las cadenas de texto no se interpretan por defecto como separadores si el archivo enmarca dichas cadenas entre comillas dobles.

Esta especificación general puede crear ambigüedades y problemas a la hora de leer ciertas matrices. Podríamos tener una matriz con columnas separadas por comas en lugar de espacios, o bien cadenas de texto con espacios que no habrían de interpretarse como separadores de columnas  (por ejemplo en una columna de nombres de países, que podría incluir algunos como "Estados Unidos"). Para evitar estos problemas se puede añadir un segundo argumento a la función, con el carácter que se utiliza como separador de columnas. Por ejemplo, si queremos especificar que las columnas del archivo `ejemplo.txt` están separadas específicamente por tabuladores o por comas:

```julia; eval=false
matriz = readdlm("ejemplo.txt", '\t')   # Separada por tabuladores
matriz = readdlm("ejemplo.txt", ',')    # Separada por comas
```

También se puede especificar, seguido del carácter de separación, otro argumento que indique el carácter que marca el fin de línea --que puede diferir entre sistemas operativos, aunque esto no suele ser tan problemático--.

La función `readdlm` también admite muchos otros argumentos opcionales para controlar cómo se interpreta el texto, que vienen explicados en su documentación. Hay dos de ellos, `skipstart` y `header`, que son particularmente útiles cuando el archivo contiene un encabezado, que a menudo incorpora los nombres de las columnas. 

Por ejemplo consideremos una pequeña tabla con los datos de esperanza de vida en los países del mundo clasificados por continente y género, que tenemos en el archivo `"esperanzadevida.txt"` (valores calculados a partir de los datos de las Naciones Unidas en 2017):

```
continente     género   media  desv_tip
África         Todos    60.23  7.25
África         Hombres  58.58  6.91
África         Mujeres  61.90  7.71
Asia           Todos    71.82  5.34
Asia           Hombres  69.95  5.41
Asia           Mujeres  73.79  5.54
Europa         Todos    77.22  3.61
Europa         Hombres  73.66  4.55
Europa         Mujeres  80.70  2.81
Latinoamérica  Todos    74.65  3.70
Latinoamérica  Hombres  71.38  3.85
Latinoamérica  Mujeres  77.96  4.11
Norteamérica   Todos    79.17  2.05
Norteamérica   Hombres  76.79  2.28
Norteamérica   Mujeres  81.50  1.79
Oceanía        Todos    77.92  6.33
Oceanía        Hombres  75.70  5.66
Oceanía        Mujeres  80.20  5.55
```

Podríamos ignorar la primera línea o extraerla como un vector de nombres, usando una de estas dos opciones:

```julia; results=hidden
# Para ignorar la primera línea especificamos `skipstart=1`
datos_un = readdlm("esperanzadevida.txt", skipstart=1)
# Para guardar la primera línea como un vector de nombres: `header=true`
(datos_un, nombres) = readdlm("esperanzadevida.txt", header=true)
```

Ambos argumentos se pueden combinar, si el encabezado contiene más líneas con otro tipo de información. En este caso `skipstart` indicaría el número de líneas a ignorar antes de leer los nombres de las columnas. Ambos son "argumentos con palabra clave", que pueden ponerse en cualquier orden después de los argumentos principales, pero tienen que ser llamados por su nombre para evitar confusiones. Por ejemplo, si hay dos líneas de texto con "metadatos" antes de la fila de nombres:

```julia; eval=false
# Todas estas expresiones son equivalentes
(datos_un, nombres) = readdlm("esperanzadevida.txt", skipstart=2, header=true)
(datos_un, nombres) = readdlm("esperanzadevida.txt", header=true, skipstart=2)
(datos_un, nombres) = readdlm("esperanzadevida.txt", '\t', skipstart=2, header=true)
```

Las matrices también pueden construirse "a mano" a partir de un conjunto de datos, de forma semejante a como se hace con los vectores. Si un vector se define escribiendo la serie de valores entre corchetes, separados por comas, las columnas de una matriz se pueden concatenar separándolas entre espacios, como se hace en la última línea del ejemplo al inicio del capítulo:

```julia; eval=false
resultados = [archivos intervalos distancias]
```

Asimismo, se pueden concatenar valores por filas separándolas por puntos y comas. Por ejemplo los datos de África de la tabla de esperanzas de vida anterior (dejando de lado los nombres de las variables y la columna con el nombre del continente) se podría escribir del siguiente modo:

```julia; display=false
datos_africa =["Todos" 60.23 7.25; "Hombres" 58.58 6.91; "Mujeres" 61.9 7.71]
```

Como ya se ha visto antes, la forma de acceder a un elemento o una submatriz para leer o modificar sus valores es una generalización de lo que se hace con los vectores. Los elementos a los que se quiere acceder se indican por su posición en la matriz, que viene dada por las filas y columnas correspondientes (separadas por una coma).

```julia
using Statistics
# La esperanza de vida media del ciudadano europeo está en la séptima fila, tercera columna
vida_europeo_medio = datos_un[7,3]
# Calculamos la esperanza de vida promedio (columna 3 completa)
# [En realidad el valor medio es distinto, por los distintos tamaños de población.]
vida_media = mean(datos_un[:,3])
```

## "Data frames" (tablas de datos)

En términos coloquiales se puede usar indistintamente el término "matriz" y el de "tabla" de datos, como ocasionalmente hemos hecho en la sección anterior, para hablar de conjuntos de números, cadenas de texto u otro tipo de variables dispuestos en una estructura regular de filas y columnas. Pero en términos más formales, todos los ejemplos que hemos visto hasta ahora son *arrays* de dos dimensiones, aunque por abreviar también se les da el nombre de matrices. El término de "tabla de datos" (*data frame* en inglés) se reserva para unas estructuras más sofisticadas que vienen definidas en el paquete [DataFrames](https://github.com/JuliaData/DataFrames.jl/), y que se pueden leer y guardar en archivos de texto a través del paquete [CSV](https://github.com/JuliaData/CSV.jl).

Una tabla de datos es parecida a una matriz; también se puede leer a partir de un archivo de texto mediante la función `CSV.read`, al igual que hacíamos con `readdlm` para las matrices, con algunas diferencias entre las cuales podemos destacar las siguientes:

* La primera línea se interpreta por defecto como la lista de nombres de las columnas. Al leer el archivo estos nombres se incorporan a la propia tabla, en lugar de devolverse como una variable aparte.

* El carácter de separación entre columnas considerado por defecto por `CSV.read` es una coma; para especificar un carácter de separación distinto se utiliza el argumento con la palabra clave `delim`. Si las columnas están separadas por más de un espacio en blanco, hay que añadir también el argumento `ignorerepeated=true`.

* Si el tipo de datos (números decimales, enteros, cadenas de texto...) es consistente en cada columna del archivo de entrada, dichos tipos se mantienen en las distintas columnas de la tabla resultante, mientras que `readdlm` crearía una matriz homogénea de tipo `Any`.

* Las columnas pueden contener valores perdidos (`missing`), que por defecto se representan mediante posiciones "vacías" (dos delimitadores seguidos). Los argumentos `missingstrings` y `allowmissing` se pueden usar para personalizar cómo se interpretan y gestionan dichos valores perdidos.

Podemos ver cómo los nombres de las columnas están incorporados en la tabla leyendo el archivo "esperanzadevida.txt" como sigue:

```julia; results="raw"
# Instalar el paquete CSV si no se ha instalado el paquete antes
using CSV
tabla_un = CSV.read("esperanzadevida.txt", delim=' ', ignorerepeated=true)
```

Además, tal como se ha señalado, el género es una serie de cadenas de texto (datos de tipo ``j typeof("a")``) mientras que la altura o el peso son numeros enteros (``j typeof(0)``). Se puede hacer referencia a las distintas columnas por su posición en la tabla al igual que en las matrices, pero también por sus nombres, que se representan en forma de símbolos (véase al final de la sección sobre cadenas de texto sobre este tipo especial de nombres):

```julia
columna_continente = tabla_un[:continente]  # Equivale a ... tabla_un[:,1]
columna_media = tabla_un[:media]            # Equivale a ... tabla_un[:,3]
```

Este tipo de tablas también se pueden crear a mano, con la función "constructora" `DataFrame` del paquete DataFrames. La forma normal de construir estas tablas es introduciendo los datos por columnas, a cada una de las cuales se le asigna un nombre. Por ejemplo, la última línea del ejemplo inicial de este capítulo podría haberse cambiado para crear una tabla de este tipo:

```julia; results="raw"
using DataFrames
tabla_resultados = DataFrame(archivo=archivos, tiempo=intervalos, distancia=distancias, proporcionxy = proporcionxy)
```

## Guardar datos

Naturalmente, además de leer datos a partir de archivos de texto, normalmente también interesa *escribir* archivos con los resultados generados. Si estos resultados están en forma de matrices o vectores, se pueden guardar a través de la función `writedlm` de DelimitedFiles, que funciona de forma simétrica a `readdlm`. Por ejemplo, para guarda la matriz `resultados` creada en el primer ejemplo de este capítulo en el archivo "tabla.txt", usando el punto y coma como separador entre columnas:

```julia; eval=false
writedlm("tabla.txt", resultados, ';')
```

Si solo se introduce el nombre del archivo y la matriz o vector de datos, por defecto `writedlm` separa las columnas con un carácter de tabulación. En el caso de tener una tabla del tipo `DataFrame`, se puede utilizar `CSV.write` para volcarla en un archivo de texto, empleando los mismos argumentos con palabra clave que emplea `readtable` para la lectura; por ejemplo:

```julia; eval=false
CSV.write("tabla.txt", tabla_resultados; delim=';')
```

La diferencia más notable entre `writedlm` y `CSV.write`, además del tipo de tabla de entrada, es que `writedlm` también escribe una primera línea con los nombres de las columnas. (Se puede omitir usando el argumento opcional `header=false`).

Guardar conjuntos de datos en archivos de texto es especialmente útil para emplearlos posteriormente, copiando la tabla en un informe, abriéndola con una hoja de cálculo, o importándola en cualquier otro programa. Pero para reutilizar los datos en una sesión de Julia posterior, otra opción práctica es guardarlos en un archivo binario que conserve todas las propiedades de las variables originales. Los paquetes [JLD2](https://github.com/JuliaIO/JLD2.jl) contiene las utilidades necesarias para salvar y cargar datos de este tipo.

Así, con la función `save` podemos seleccionar un conjunto de variables en una sesión de Julia, y guardarlas en un archivo asignándoles nombres arbitrarios (no necesariamente iguales a los de las variables originales). Siguiendo con el mismo ejemplo del inicio del capítulo, puede interesarnos guardar la lista de los archivos de entrada (`archivos`), la ruta en la que se encuentran (`directorio`) y la matriz `resultados`. Imaginemos que queremos guardar estos datos en un archivo dándole a cada variable su correspondiente nombre en inglés. La sintaxis sería:

```julia; eval=false
using JLD2
save("datos.jld", "filenames", archivos, "path", directorio, "result_matrix", resultados)
```

Cada una de estas variables puede recargarse posteriormente, mediante la función `load` especificando el nombre de la variable a recuperar:

```julia; eval=false
matriz_resultados = load("datos.jld", "result_matrix")
```

Para abreviar se puede omitir la variable a extraer, por ejemplo escribiendo `load("datos.jld")`, aunque en este caso todas las variables guardadas se recogen en un solo objeto de Julia de tipo "diccionario" (véase el capítulo XXXXXXXX). Una alternativa tanto para guardar el "espacio de trabajo" completo como para recuperarlo sin tener que especificar las variables de interés son las "macros" `@save` y `@load`, respectivamente:

```julia; eval=false
# Salvar todo el espacio de trabajo:
@save("datos.jld")
# Salvar las mismas variables que antes, usando sus propios nombres:
@save("datos jld", archivos,directorio resultados)
# Cargar todas las variables guardadas en "archivo.jld"
@load("datos.jld")
```

# Repaso de lo aprendido

En este capítulo hemos hecho una introducción a los siguientes aspectos de Julia, en los que se profundizará más en próximos capítulos:

* La forma de expresar operaciones algebraicas y comparaciones básicas en la sintaxis de Julia.
* El uso de *arrays*, en particular los vectores (*arrays* unidimensionales) y matrices (*arrays* bidimensionales), incluyendo:
    + Métodos para componer *arrays* a partir de datos numéricos.
    + Expresiones para identificar un rango de elementos, filas o columnas de un *array*.
    + Cómo extraer una sección de un *array* y modificar sus valores.
    + Las expresiones "con punto" para aplicar una operación a cada uno de los elementos de un *
* El uso del módulo `DelimitedFiles` y los paquetes `DataFrames` y `CSV` para trabajar con datos tabulados.
* Aspectos esenciales de las cadenas de texto (*strings*), letras aisladas (caracteres) y variables de tipo "símbolo".
* La interpolación en la definición de cadenas de texto.
* El paquete `JLD2` para salvar y recuperar las variables de una sesión de trabajo.
* El uso de funciones con argumentos identificados por una paalbra clave.

Además podemos destacar el uso de las siguientes funciones:

* `findmax`, `findmin` para localizar respectivamente el valor máximo y el mínimo de una variable.
* `length` para obtener la longitud de un *array* u otra estructura con múltiples datos.
* `readdir` para obener una lista de cadenas de texto con los nombres de los archivos de un directorio.
* `readdlm` y `CSV.read` (esta última del paquete `CSV`) para leer datos tabulados, más las correspondientes `writedlm`, `CSV.read` para escribirlos en un archivo de texto.
* `sign` para obtener el signo de una variable numérica.
* `sqrt` para calcular la raíz cuadrada de un número.
* `save` y su opuesta, `load`, para salvar en disco y recuperar después los contenidos de uno o varios archivos, más sus correspondientes "macros" `@save` y `@load` para salvar y cargar todo el espacio de trabajo actual.
* `zeros` para crear un array lleno de ceros al inicio.


```julia; echo=false
cd(dirbase)
Weave.restore_chunk_defaults()
```



