# Primeros pasos

## Instalación de Julia

Obviamente, lo primero que se necesita para trabajar con cualquier lenguaje de programación son las herramientas para crear y ejecutar los programas. El software básico para usar Julia está disponible en su página oficial (https://julialang.org/downloads), en forma de código fuente así como en binarios preparados para instalar en Windows, Mac OS X, y algunas distribuciones de Linux. Desde esa página se pueden encontrar también enlaces con explicaciones detalladas sobre cómo instalar y ejecutar Julia, que son específicas para cada sistema, y por lo tanto no desarrollaremos aquí.

El paquete básico de Julia presenta una sencilla consola de comandos (figura 1), ligera y rápida, útil para realizar pruebas o rutinas sencillas. Sin embargo, para muchos usuarios este tipo de interfaz es poco amigable, y las "ayudas" que proporciona (invocación de instrucciones anteriores usando las flechas de "arriba"/"abajo", combinaciones de teclas disponibles para acelerar las operaciones de corta-y-pega, etc.) resultan insuficientes. Por otro lado, para ejecutar rutinas más complejas, y siempre que se quiera obtener resultados reproducibles, es recomendable escribir las instrucciones en un archivo de código (*script*), y luego ejecutarlo en Julia. Con la interfaz básica se puede ejecutar un *script* (véase un ejemplo en la siguiente sección), pero para escribirlo se necesitaría un programa auxiliar.

![](../imgs/repl.png)

Para combinar ambas tareas de forma eficiente en una sola interfaz lo habitual es usar los llamados "entornos de desarrollo integrados" (conocidos por sus siglas IDE en inglés), que pueden ser programas específicos para el lenguaje en cuestión, o aplicaciones genéricas con módulos particulares para distintos lenguajes. Para el usuario que se inicia en Julia se pueden recomendar dos paquetes de software gratuitos coin IDE incluída, desarrollados por [Julia Computing](https://juliacomputing.com), una compañía fundada por los creadores del lenguaje para ofrecer servicios profesionales.

El más sencillo de usar es [Julia Box](https://juliabox.com/), una plataforma web para crear "cuadernos de notas" (*notebooks*) en Julia. En estos cuadernos se puede escribir texto normal (incluyendo formatos de letra, estilos de título y de párrafo, etc.) e intercalarlo con bloques de código que se pueden ejecutar *in situ* con un click de ratón, de forma que los resultados (incluyendo gráficos) aparecen entre los párrafos de texto a continuación del código (figura 2). Una diferencia esencial respecto a la consola de comandos, además de poder alternar texto normal con código, es que se pueden retocar los bloques de código ya ejecutados (y volver a ejecutarlos para actualizar los resultados). 

[FIGURA JULIABOX]

Otra ventaja de Julia Box es que se puede utilizar desde un navegador de Internet sin siquiera tener Julia instalado en el ordenador; lo único que hace falta es una cuenta de Github, Linkedin o Google con la que registarse para entrar. Trabajar con esta herramienta online tiene algunas limitaciones, pero es un recurso práctico en particular para hacer pruebas o para estudiantes. Julia Box está basado en [Jupyter](http://jupyter.org/), una evolución de la plataforma IPython que se desarrolló originalmente para hacer *notebooks* de Python, y desde la misma web de Jupyter se pueden también hacer pruebas más elementales con Julia (con una funcionalidad más limitada), sin tan siquiera registrarse, entrando de forma anónima en https://try.jupyter.org/ y abriendo un cuaderno de Julia.

Otro paquete más completo es [Julia Pro](https://juliacomputing.com/products/juliapro.html), una aplicación de escritorio (esta sí tiene que instalarse), que permite trabajar con la interfaz de [Juno](http://junolab.org/), otro IDE para Julia basado en el editor de código [Atom](https://atom.io/). La interfaz de Juno tiene varios paneles, incluyendo una consola de comandos, visores de variables y gráficas, y un editor de código para trabajar con uno o varios archivos a la vez. Además de para escribir el código, este editor sirve para ejecutarlo, bien todo completo o por línas o bloques seleccionados; los resultados se pueden visualizar directamente en el archivo de código (parecido a como funciona en los *notebooks*) o en los otros paneles (figura 3).

[FIGURA JUNO]

La elección de una de estas dos alternativas (o incluso otras que no se mencionan aquí) depende de las necesidades del usuario, por lo que en este manual no se da ninguna preferencia. Los ejemplos que se presentarán a partir de ahora estarán dirigidos a un uso genérico, que se puede hacer tanto en Jupyter como Juno, o incluso en la consola de comandos básica de Julia.

!!! note

    Para los usuarios interesados en los términos legales, es conveniente destacar que la licencia de uso de Julia Pro es más restrictiva que la licencia MIT o BSD con la que están publicados sus componentes individuales (Julia, Juno, Jupyter, etc.). Para mantener vigentes los términos más abiertos de las licencias originales es posible (aunque lleva más trabajo) instalarse e integrar los distintos componentes a mano.

## Un ejemplo básico

Veamos ahora un ejemplo práctico de ambas formas de uso, con un programa sencillo para calcular el día de la semana en el que cae cualquier fecha del calendario Gregoriano, usando el algoritmo de Gauss tal como está publicado por Bernt Schwerdtfeger.[^1] Se trata de un algoritmo simple, que podría traducirse a Julia mediante el siguiente código: 

```julia
"""
Cálculo del día de la semana.
La función devuelve una cadena de texto con el día de la semana que corresponde
a los números de día, mes y año introducidos como los argumentos numéricos
`d`, `m`, `y`, respectivamente.
"""
function gauss_diasemana(d, m, y)
    # Enero y febrero (m=1, m=2) se tratan como el año anterior
    # en torno a los años bisiestos
    if m < 3
        y = y - 1
    end
    # Dividir el año entre centenas (c) y el resto (g)
    c = div(y, 100)
    g = mod(y, 100)
    # Definir e y f en función del mes (de 1 a 12) y el siglo
    # (en ciclos de 400 años --- 4 siglos)
    earray = [0,3,2,5,0,3,5,1,4,6,2,4]
    farray = [0,5,3,1]
    e = earray[m]
    f = farray[mod(c,4)+1]
    # Seleccionar el día de la semana en función del cálculo de Gauss
    warray = ["domingo","lunes","martes","miércoles",
        "jueves","viernes","sábado"]
    w = mod(d + e + f + g + div(g, 4), 7)
    return(warray[w+1])
end
```

[^1]: http://berndt-schwerdtfeger.de/cal/cal.pdf

Supongamos que el código mostrado arriba está guardado en un archivo llamado `calc_diasemana.jl` (el nombre del archivo es arbitrario, y puede ser cualquier nombre aceptado por el sistema operativo. El programa consiste en una sola función con 3 argumentos (los números del día, el mes y el año), basada en unas pocas divisiones enteras (definidas en la función `div`) y el cálculo de "restos" de dichas divisiones (`mod`),[^2] más la selección de unos valores a partir de los resultados intermedios y unas listas predefinidas.

[^2]: Existen dos funciones para el resto de una división: `mod` y `rem`, que funcionan de forma distinta cuando alguno de los dos operandos es negativo. Para el caso que nos ocupa esa diferencia no es relevante.

Este programa se puede cargar usando la función `include` en la consola de Julia, como sigue:

```julia; eval=false
include("calc_diasemana.jl")
```

El resultado posiblemente sea algo decepcionante, porque lo único que se ha hecho es definir una función, que por sí misma no da ningún resultado. Por otro lado, lo más probable es que al introducir esa línea sin más ni siquiera se obtenga ningún resultado, sino un error debido a que no se encuentra el archivo de código.[^3] Para asegurarse de que Julia encuentra el archivo hay varias alternativas:

  * Copiar el archivo de código `calc_diasemana.jl` al directorio de trabajo de Julia. La ruta de ese directorio se puede obtener con la función `pwd()` -- sin ningún argumento--.
  * Cambiar el directorio de trabajo al lugar que contiene el archivo. El cambio de directorio se hace con la función `cd`, que recibe un solo argumento: el nombre del directorio destino. Este se puede definir literalmente como un texto entre comillas dobles, o ser una variable que contiene dicho texto.
  * Introducir la ruta completa del archivo de código en la llamada a `include`. Esta se puede escribir literalmente, o si el directorio que contiene el archivo está definido en una variable (supongamos que esta variable se llama `dir_include`, la ruta se puede componer con la función `joinpath`. Es decir, la expresión anterior sería `include(joinpath(dir_include, "calc_diasemana.jl"))`.

[^3]: Ref. a sección con información sobre LOAD_PATH y require()

Una dificultad añadida es que a veces los nombres de los directorios son largos y resulta tedioso escribirlos. De hecho, lo más natural para la mayoría de la gente es utilizar entornos gráficos para seleccionar y definir rutas y nombres de archivos. La interfaz de Juno permite definir el directorio de trabajo a través de los menús. Como alternativa si se está trabajando con la consola de comandos, se puede copiar el nombre del directorio desde el gestor de archivos al "portapapeles", y convertirlo en una variable de texto mediante la función `clipboard`. Por ejemplo, con la expresión `directorio = clipboard()`.

Otra alternativa útil es usar diálogos gráficos aportados por paquetes externos, como (entre otros) [Gtk](https://github.com/JuliaGraphics/Gtk.jl), basado en la libería Gtk, que dispone de las siguientes funciones para seleccionar archivos o directorios (véase más abajo sobre el uso de paquetes en Julia):

* `open_dialog()` para seleccionar la ruta completa a un archivo existente.
* `save_dialog()` para seleccionar la ruta de un archivo (tanto existente como uno nuevo).

Pueden verse los detalles sobre cómo usar estas funciones en http://juliagraphics.github.io/Gtk.jl/latest/manual/filedialogs.html

Una vez se ha conseguido cargar el archivo que define la función, esta ya se puede usar para obtener un resultado de verdad. Por ejemplo, para conocer en qué día de la semana cayó 11 de agosto de 2018, la fecha en la que se publicó la version 1.0.0 de Julia:

```julia
gauss_diasemana(11, 8, 2018)
```

Lo que se hace "en un día cualquiera" usando Julia es esencialmente este modelo de rutina, con funciones más complicadas y muchas más operaciones interactivas, explorando resultados, corrigiendo argumentos y repitiendo operaciones, claro está.

## Sintaxis básica

Para escribir un programa en Julia o cualquier otro lenguaje de programación hay que seguir una serie de reglas sintácticas, la mayoría de las cuales en realidad no es necesario explicar, ya que son reglas de escritura lógicas e intuitivas, o se desprenden directamente de la lectura de ejemplos. A continuación se mencionan algunos detalles básicos que se pueden observar en el anterior ejemplo del [algoritmo de Gauss](#gauss_diasemana):

  * Cada operación se escribe normalmente en una línea distinta, aunque es posible "partir" las expresiones en varias líneas. Si una línea acaba con una expresión incompleta se asume que continúa en la siguiente, como ocurre en la definición de la variable `warray` con los nombres de los días de la semana.
  
  * Todo el texto que sigue al símolo `#` hasta el final de la línea se considera un comentario, y no se ejecuta.

  * Las expresiones más habituales son las del tipo `a = f(b)`, como `c = div(y, 100)`, donde `a` es un nombre de variable, `f` el nombre de una función, y `b` el número, cadena de texto u otro tipo de argumento sobre el que opera esa función, o bien el nombre de la variable a la que se le ha asignado el valor de ese argumento. (La función también puede aceptar varios argumentos de entrada, como ocurre con `div`, o tener varias salidas, que se presentan como variables separadas por comas.)
  
  * También es habitual encontrarse expresiones del tipo `a = f[b]`, p.ej. en `e = earray[m]`, con corchetes en lugar de paréntesis. En esos casos `f` no es una función sino un vector, matriz u otra estructura de datos, y `b` es el índice o clave que identifica la parte de su contenido que se asignará a la variable `a`.
  
  * Los nombres de variables, funciones, etc. pueden estar formados por cualquier combinación de letras y números, más guiones bajos, exceptuando nombres que comiencen por números y las palabras clave del lenguaje (como `for`, `if`, `end`, etc.). Además, también se admiten nombres con caracteres Unicode más allá del ASCII básico (letras acentuadas, griegas, etc.), así como el signo de exclamación (`!`) en posición no inicial, aunque conviene usarlos con mesura: emplear caracteres extendidos aumenta el riesgo de problemas de portabilidad de los programas, y la exclamación se suele resevar para el nombre de cierto tipo de funciones (las que modifican sus argumentos de entrada).

  * Los bloques de código (funciones, bloques condicionales, etc.) se delimitan cerrándolos con la palabra clave `end`. Se recomienda indentar las líneas interiores al código para hacerlo más legible, aunque el programa funcionaría igualmente si no se hace.
  
  * En general los espacios son irrelevantes: siempre que haya algun símbolo delimitador (operadores matemáticos, signos de puntuación, paréntesis...) pueden usarse uno, varios o ningún espacio entre nombres de variables, funciones, etc., o al principio de la línea, excepto al inicio de las llamadas a "macros" (véase el capítulo XXXXXXXXXXXXXXXXXXXXXXX).

Hay más reglas importantes que conviene tener en cuenta para programar en Julia, aunque para contener el tamaño de esta introducción, se comentan con más detalle en el capítulo XXXXXXXXXXXXXXXXXX.

## Módulos y paquetes

Cuando se inicia una sesión de Julia, por defecto solo están disponibles una serie de utilidades elementales, y para la mayoría de proyectos hace falta usar "módulos" que contienen funciones y otras utilidades complementarias. Por ejemplo, en un proyecto en el que se quieran hacer cálculos estadísticos (incluso al nivel básico de medias, varianzas, etc.), hace falta usar el módulo `Statistics`. Para ello hay que ejecutar el siguiente comando:

```julia
using Statistics
```

La distribución básica de Julia viene con una biblioteca estándar que incluye diversos módulos. Estos módulos no están activados por defecto para que la sesión de trabajo no se cargue innecesariamente con tipos de variables y funciones que no se vayan a usar &mdash; o cuyo nombre el usuario quiera emplear para otros propósitos. (Normalmente habrá una serie de módulos que se usen de forma habitual, pero el conjunto de estos módulos "esenciales" varía según el campo en el que se trabaje.) La lista de módulos de la bilbioteca estándar se puede consultar en la [documentación oficial](https://docs.julialang.org/en/stable/). Algunos de los que es más probable que se usen en proyectos de muchos ámbitos son:

* `Dates` para trabajar con fechas y unidades de tiempo.
* `DelimitedFiles` para leer y escribir tablas de datos en ficheros de texto.
* `LinearAlgebra` para análisis y operaciones avanzadas con matrices.
* `Statistics` para cálculos estadísticos (a menudo junto con `Random` para trabajar con números aleatorios y distribuciones de probabilidad).
* `Sockets` para trabajar con conexiones a redes informáticas.

Hay muchas otras utilidades que pueden considerse importantes, incluso fundamentales por la mayoría de los potenciales usuarios, como representaciones gráficas de datos, editor de código, ayudas para la depuración de rutinas (*debugging*), etc., pero no están incluidas en la biblioteca estándar, sino en un "ecosistema" de paquetes que se han desarrollo de forma coordinada (aunque independiente) por la comunidad de usuarios y desarrolladores de Julia. Puede consultarse la sección *Ecosystem* en la web oficial (https://julialang.org) para ver algunos de los dominios principales, o la web [Julia Observer](https://juliaobserver.com/) para explorar todos los paquetes publicados.

Las soluciones más completas como Julia Box o Julia Pro ya incorporan muchos de los paquetes más importantes, pero incluso en esos casos puede ser necesario gestionarlos, actualizarlos o añadir nuevos paquetes. En el caso de paquetes "registrados" oficialmente (que es el caso de los más populares, y todos los que se comentan en esta guía), la forma más sencilla de instalarlos es desde el modo de gestión de paquetes de la línea de comandos, mediante los siguientes pasos:

1. Cambiar del modo "normal" al de gestión de paquetes ("pkg"), pulsando la tecla `]` (se verá un cambio en la etiqueta al comienzo de cada línea, como en la figura XXXXXXXXXXX).
2. Escribir el comando `add` seguido del nombre del paquete. Por ejemplo, para añadir el paquete Gtk comentado antes: `add Gtk`
3. Cambiar de nuevo al modo normal, pulsando la tecla de borrar al comienzo de la línea.

A continuación ya se podrá usar el paquete como un módulo más. Por ejemplo, si se quiere usar la función `open_dialog` de Gtk para seleccionar un archivo de código y luego incluirlo, después de instalar el paquete se haría:

```julia; eval=false
using Gtk
archivo = open_dialot("Selecciona el archivo")
include(archivo)
```

## Buscando ayuda

Con toda seguridad, al programar en Julia pronto te encontrarás con dificultades que no puedes resolver con la información que se recoge en este manual, y necesitarás ayuda adicional. Lo primero con lo que se ha de contar es el manual de referencia oficial (https://docs.julialang.org/en/stable/), que contiene numerosos detalles de múltiples aspectos del lenguaje, y también explica el uso de todas las funciones que forman parte del paquete "básico" de Julia.

El documento de referencia para las funciones es clave incluso para los programadores experimentados, ya que uno de los problemas más recurrentes es la dificultad de recordar cómo se usa cierta función (qué argumentos acepta, qué resultados proporciona, etc.). Un atajo práctico cuando se trabaja en modo de línea de comandos consiste en escribir el signo de interrogación (`?`) al principio de una instrucción. Al hacerlo la interfaz cambia al "modo de ayuda" (la etiqueta que marca el comienzo de la línea cambia de `julia>` a `help?>`), y al introducir el nombre de la función (sin paréntesis ni argumentos, solo el nombre) aparece en pantalla el texto de referencia.

Se puede probar con cualquier función básica (por ejemplo `?div` para leer la ayuda sobre la división entre enteros), con un operador (p.ej. `?+` para la suma), o incluso para una variable que se haya definido (en ese caso dará una información básica sobre su contenido).

!!! note """Documentación a través de "docstrings" """

    Si has realizado el ejercicio de crear la función [`gauss_diasemana`](#gauss_diasemana) con el código completo presentado en este capítulo, al escribir `?gauss_diasemana` podrás leer el texto de las líneas que preceden a la definición de la función. Esta forma de documentar las funciones u otro tipo de objetos es muy útil y recomendable para hacer programas trazables y comprensibles.

Para las dudas no resueltas en el  manual, entre otras cuestions, los creadores de Julia han organizado un foro de debate y preguntas, disponible en https://discourse.julialang.org (en inglés). Y además existen múltiples foros y redes sociales (también en español y otros idiomas), tanto promovidas por los desarrolladores como por los propios usuarios, donde se pueden encontrar infinidad de consultas pasadas y hacer nuevas. Una buena recopilación de estas redes se puede encontrar en https://julialang.org/community/

## Repaso de lo aprendido

En este primer y breve capítulo hemos aprendido los siguientes puntos fundamentales para trabajar en Julia:

* Los distintos entornos disponibles: la interfaz de comandos, *notebooks* de Jupyter y el IDE de Juno.
* Algunas reglas básicas de sintaxis del lenguaje.
* Cómo instalar y cargar paquetes.
* Algunas utilidades del paquete `Gtk` para definir nombres de directorios y archivos a través de ventanas gráficas.
* Cómo buscar ayuda.

Además, a lo largo de las explicaciones hemos empleado las siguientes funciones particulares (además de las propias de la gestión de paquetes y las de `Gtk`):

* `cd` y `pwd` para definir y consultar el directorio de trabajo, respectivamente.
* `div` para divisiones enteras y `mod` para el resto de una división.
* `include` para ejecutar *scripts*.
* `joinpath` para componer nombres de directorios y archivos.

