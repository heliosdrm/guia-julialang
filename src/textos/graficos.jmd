# Gráficos

```julia; echo=false; results="hidden"
import Weave
Weave.set_chunk_defaults(Dict{Symbol,Any}(:display=>true))
dirbase = pwd()
cd("../datos")
```

En los capítulos anteriores de esta guía hemos hecho un tratamiento superficial, incluso podría decirse que apresurado, de unos pocos aspectos básicos en los que muchos otros manuales, sean de Julia o cualquier otro lenguaje de programación, suelen ser más detallados en sus capítulos introductorios. En este capítulo dedicado a los gráficos, sin embargo, vamos a detenernos más a pesar de que es una funcionalidad bastante avanzada, y requiere instalar unos cuantos paquetes auxiliares y librerías externas para empezar.

Hay una buena razón para hacerlo así. El usuario de una herramienta informática normalmente no juzga si una tarea es "básica" o "avanzada" según las complejidades que supone para esa herramienta, sino por cuestiones más prácticas. Y explorar visualmente los datos es una de las primeras cosas que se suele hace después de recogerlos, como mínimo para valorar si parecen correctos o hay algún tipo de anomalía. En este sentido los gráficos podrían considerarse como una de las tareas más básicas. De hecho no es raro que el ansia por ver qué pinta tienen los datos conduzca a atajos "sucios y rápidos", como abrir los ficheros con una hoja de cálculo e improvisar gráficas con un par de *clicks* de ratón, antes de empezar los preparativos para un análisis más formal.

Parece lógico, por tanto, que las instrucciones para crear gráficos también se introduzcan lo más pronto posible a la hora de presentar una herramienta para el análisis de datos. Además, parafraseando el refrán popular, se puede decir que un gráfico vale más que mil números. Julia tiene una potencia extaordinaria para hacer cálculos complejos y costosos de forma rápida y eficaz; pero la representación en un bonito gráfico interactivo de un análisis de datos sencillo a veces da una mayor sensación de productividad, y aprender a crear esos gráficos es una buena manera de aumentar la motivación para introducirse en un lenguaje de programación.

## El paquete Plots y librerías gráficas para Julia

Julia nos ofrece la versatilidad y potencia de múltiples herramientas externas para generar gráficos, a través de paquetes complementarios que instalan automáticamente las librerías necesarias y proporcionan funciones para manejarlas desde Julia. Además, el paquete [Plots](https://github.com/JuliaPlots/Plots.jl) proporciona una interfaz común para manejar muchos de esos otros paquetes, de tal manera que solo hace falta aprender una forma de crear y editar gráficos.

### Ejemplo de Plots con GR

Por ejemplo, el gráfico con el ejemplo de las señales oscilatorias analizadas en el capítulo anterior está creado con [GR](http://gr-framework.org), una librería gráfica *open source* que se integra en Julia a través del paquete [GR](https://github.com/jheinen/GR.jl), el cual se instala automáticamente junto con Plots. Las instrucciones seguidas para obtener este gráfico son las siguientes:


```julia
# Primero leemos el archivo con las series de datos datos a representar
# (la primera columna tiene los tiempos, y las otras dos las coordenadas)
using DelimitedFiles
datos = readdlm("series/sA01.txt")
# Cargamos el paquete Plots y seleccionamos `gr` como herramienta gráfica
using Plots
gr()
# Dibujamos la línea de las `x` (segunda columna)
plot(datos[:,1], datos[:,2], label="x")
# Añadimos la línea de las `y`
plot!(datos[:,1], datos[:,3], label="y")
```

Estas instrucciones, que luego comentaremos con más detalle, son las mismas que se utilizarían para crear ese gráfico con cualquier otra librería soportada por Plots, excepto la línea en la que se selecciona la librería en cuestión. (En este caso `gr()`; la forma de seleccionar la librería siempre es mediante una función con el nombre en minúsculas del paquete asociado de Julia, que naturalmente ha de estar instalado con anterioridad.)

A continuación se muestran ejemplos de este mismo gráfico creado con otras de las principales librerías soportadas por Plots, junto con algunas indicaciones específicas relacionadas con las maneras en las que se pueden presentar los gráficos. Hay que tener en cuenta que su visualización puede depender de las herramientas gráficas empleadas, así como del entorno en el que se trabaja. Según el caso, las gráficas pueden presentarse intercaladas con el código, en una ventana gráfica especial, o como una página web en un navegador.

### Plotly/PlotlyJS

```julia; echo=false
plotlyjs()
plot(datos[:,1], datos[:,2:3], label=["x" "y"])
```

[Plotly](https://plot.ly/) es una plataforma web para crear gráficos interactivos y publicarlos online. Estos gráficos son muy prácticos para inspeccionar los datos representados, con herramientas hacer zoom, salvarlos en otro formato, etc. y se integran muy bien en documentos HTML, como se puede ver en el ejemplo. Sus desarrolladores también han creado una librería *open source* basada en Javascript llamada [Plotly.js](https://plot.ly/javascript/), que permite crear estos gráficos de forma local, y sin tener una cuenta de usuario en su plataforma.

Para interactuar con la plataforma online Julia dispone del paquete [Plotly](https://github.com/plotly/Plotly.jl), aunque si no se requieren los servicios online también es práctico trabajar con la librería de Javascript, usando el paquete [PlotlyJS](https://github.com/sglyon/PlotlyJS.jl). Ambos están soportados por Plots.

Cuando se trabaja en la línea de comandos o en Juno, los gráficos de PlotlyJS se abren por defecto como una página web en un navegador. Alternativamente se puede configurar para que se presenten en una ventana gráfica propia, ejecutando las siguientes instrucciones (solo la primera vez):


```julia; eval=false
using Blink
Blink.AtomShell.install()
```

### Matplotlib (PyPlot)

```julia; echo=false
pyplot()
plot(datos[:,1], datos[:,2:3], label=["x" "y"])
```

[Matplotlib](http://matplotlib.org) es la librería que suele utilizarse para crear gráficos científicos en Python. Como ventaja se puede destacar que es la librería que cubre un mayor rango de las opciones de Plots. Se maneja a través del paquete [PyPlot](https://github.com/JuliaPy/PyPlot.jl). En un entorno de Python estos gráficos son interactivos, pero en ciertos contextos de uso en Julia, como en un *notebook* o en el panel de gráficos de Juno, pasan a ser directamente imágenes estáticas. Como alternativa se puede forzar su presentación en una ventana propia como las empleadas por Python para manipularlos, con las siguientes instrucciones:

```julia; eval=false
using PyCall
pygui(true)
```

Para poder emplear la librería Matplotlib, el paquete PyPlot también instala y configura un conjunto reducido de herramientas de Python, salvo que detecte que el ordenador ya dispone de ellas. En este caso intenta utilizar los recursos de Python ya instalados, lo cual aligera la instalación, pero puede que PyPlot dé fallos si la configuración de Python no es la esperada. Para ahorrarse quebraderos de cabeza se puede forzar que Julia ignore cualquier distribución existente de Python y trabaje con la suya propia, a través de la instrucción `ENV["PYTHON"]=""`. Para que sea eficaz esta instrucción ha de ejecutarse antes de instalar o configurar los paquetes que interactúan con Python. Por ejemplo, antes de instalar el paquete PyPlot:

```julia; eval=false
ENV["PYTHON"] = ""
Pkg.add("PyPlot")
```

O si PyPlot ya está instalado, para reconfigurar el entorno de Python antes de usarlo por primera vez en una sesión:

```julia; eval=false
ENV["PYTHON"] = ""
Pkg.build("PyCall")
using PyPlot
```

### UnicodePlots

```julia; echo=false
unicodeplots()
plot(datos[:,1], datos[:,2:3], label=["x" "y"])
```

No hay mucha gente que suela interesarse por hacer gráficos basados en elementos de texto, por lo que esta opción se presenta principalmente como una curiosidad, aunque tiene una ventaja sobre todas las anteriores: no hace falta instalar ninguna librería gráfica externa; lo único que se requiere es el paquete [UnicodePlots](https://github.com/Evizero/UnicodePlots.jl), que contiene solo un módulo de Julia "puro y duro" con unas dependencias mínimas.

Ante la variedad de librerías gráficas disponibles (las mencionadas y unas cuantas más), naturalmente surge la pregunta: ¿cuál conviene usar? Hay múltiples factores que se deben tener en cuenta a la hora de decidir, pero en general se puede tener en cuenta que:

* GR es la opción por defecto y la más eficiente para obtener gráficos rápidos y sencillos (si no contamos el caso extremo de UnicodePlots).
* Plotly(JS) es la mejor opción para gráficos interactivos, visualmente muy bien acabados.
* PyPlot es la opción más versátil y con más opciones disponibles que cualquiera, aunque también la más costosa de instalar.

## Componentes de los gráficos

Antes de explicar con detalle las instrucciones para crear gráficos en Julia, vamos a ver cuál es la estructura de un gráfico y los elementos que lo componen, lo cual ayudará posteriormente a entender cómo emplear las funciones que ofrece el paquete Plots. Empezando por el componente más amplio, y descendiendo progresivamente en el nivel de detalle, podemos decir que un gráfico está formado por:

[ESQUEMA GRÁFICO]

* Un marco global, que también suele recibir el nombre de "figura", que es el contenedor de todos los elementos de un gráfico. Puede ser una ventana, una página de un documento o un cuadro dentro de la misma en la que se enmarca el gráfico, etc.

* Un panel o lienzo sobre el que se organizan los elementos del gráfico: los ejes de coordenadas y sus etiquetas, el título, las leyendas, etc. La diferencia con el marco o figura global se puede apreciar con más claridad en las composiciones de gráficos, donde se disponen varios paneles, que en inglés también se suelen llamar *subplots*.

* El plano en el que se proyecta el espacio de coordenadas en el que se representa el conjunto de datos. Suele ser un rectángulo, aunque hay gráficos en coordenadas polares con una disposición circular. Habitualmente hay una relación lineal entre las medidas de los ejes horizontal y vertical (o radial y angular) y las coordenadas representadas, pero también puede haber un cambio de escala (p.ej. logarítmica), y pueden darse otras transformaciones.

* Los elementos geométricos a través de los cuales se representan los datos en el espacio de coordenadas. Estos elementos geométricos se caracterizan por su forma (líneas, puntos, figuras, textos...), su posición en el sistema de coordenadas y sus atributos estéticos como el tamaño, color y otras propiedades. La forma de estos elementos geométricos y la relación de su posición y otros atributos con el valor de los datos representados, son lo que determina principalmente la tipología de gráfico. Hay muchos prototipos que reciben nombre propio: por ejemplo "diagramas de dispersión" cuando se dibujan puntos en las coordenadas correspondientes a los valores de los datos; "gráfico de burbujas" cuando en vez de puntos se dibujan círculos con un tamaño definido por otra variable; "diagramas de barras" cuando se emplean bloques rectangulares de altura definida por los valores de los datos; o "histogramas" para el mismo tipo de diagrama, pero con barras de tamaño definido por las agrupaciones de datos con valores semejantes, etc.

En Julia estos cuatro componentes reciben los nombres de `Plot`, `Subplot`, `Axis` y `Series`, respectivamente. Conociendo esto y los principios básicos de un par de funciones que se explican en la siguientes sección, ya se pueden hacer la mayoría de los gráficos que permite construir Plots, aunque también hay bastantes más funciones que ayudan a hacer gráficos prototípicos de forma más sencilla y eficaz. Los usuarios incluso pueden crearse sus propias "recetas" de gráficos, aunque esto es un tema más avanzado que no trataremos en este capítulo.

## La función `plot` y los atributos gráficos

La herramienta principal y más potente del paquete Plots es la función `plot`, que se puede emplear de infinidad de formas. La más sencilla es simplemente:

```julia; eval=false
plot(y)
```

donde `y` es una serie de datos numéricos. Esta instrucción generaría un gráfico en un plano de coordenadas rectangular, con una línea (etiquetada como `y1`) que uniría puntos cuyas ordenadas (eje Y) son los valores de la serie, y las abscisas (eje X) son números enteros correlativos empezando por el 1. Por verlo en un ejemplo, si usamos la serie de los 10 primeros números primos:

```julia
diezprimos = [1,2,3,5,7,11,13,17,19,23]
plot(diezprimos)
```

En lugar de una sola serie de datos se pueden proporcionar dos o tres para precisar más la posición de las coordenadas de las líneas:

```julia; eval=false
plot(x,y)
plot(x,y,z)
```

En el primer caso se da un valor explícito al eje de abscisas (`x`); en el segundo se añade una tercera dimensión (`z`), y lo que se plasma en el plano de coordenadas es una proyección del espacio tridimensional.

Ahora bien, con esto solo tenemos un tipo de gráfico, en el que todos los componentes menos las coordenadas de los elementos geométricos empleados (líneas) están predeterminados. Lo que nos permite manipular todas las demás características del gráfico son los llamados "atributos", que son argumentos adicionales con nombre clave que se pueden especificar después de las coordenadas. Por empezar con un caso muy sencillo, recordemos las líneas utilizadas para crear el gráfico de ejemplo:

```julia; eval=false
plot(datos[:,1], datos[:,2], label="x")
plot!(datos[:,1], datos[:,3], label="y")
```

En estas líneas hemos especificado el atributo `label`, para sustituir los nombres `y1`, `y2` que saldrían por defecto por `x`, `y`. Nótese que para añadir la segunda línea hemos utilizado la función `plot!`, que se diferencia de `plot` en que sirve para modificar el gráfico actual, en lugar de crear uno nuevo; por lo demás ambas funciones son iguales.

Como las dos series de datos en las líneas del ejemplo tienen la misma longitud, también podríamos haber creado el gráfico en una sola orden, juntando las dos columnas en una misma matriz. En ese caso, en el atributo `label` deberían agruparse las dos etiquetas de la leyenda, también organizadas por columnas:

```julia; eval=false
plot(datos[:,1], datos[:,2:3], label=["x" "y"])
```

(Véase como el elemento asignado a `label` no es un vector unidimensional sino una matriz con dos columnas --y una fila--, ya que las dos etiquetas están separadas por un espacio, no por comas o punto y coma.)

Siguiendo la misma lógica podríamos modificar otros aspectos del gráfico. Por ejemplo podríamos generar un gráfico apto para publicar en blanco y negro, forzando el color de ambas series al negro, y especificando dos tipos de línea distintos para cada serie (continua y discontinua, respectivamente):

```julia
plot(datos[:,1], datos[:,2:3], color=:black, style=[:solid :dash])
```

Los atributos que se pueden manipular no se limitan a las características de las series de datos, sino que cubren las propiedades de todos los elementos del gráfico. El nombre de los atributos disponibles (como `color` y `style`), y los valores que se les pueden pasar (en este caso símbolos con los nombres de los colores y tipos de línea en inglés) se pueden buscar en la documentación del paquete Plots, concretamente en la página http://docs.juliaplots.org/latest/supported/. También se pueden consultar desde Julia, con la función `plotattr`:

* `plotattr()` recuerda los cuatro componentes de un gráfico cuyos atributos se pueden especificar, que son los que se han descrito en la sección anterior: `Plot`, `Subplot`, `Axis` y `Series`.

* `plotattr(:Series)` proporciona una lista en orden alfabético de los atributos asociados al componente `Series`. Lo mismo ocure con los otros componentes, cambiando `:Series` por el símbolo del nombre que corresponda (`:Axis`, `:Subplot` o `:Plot`).

* `plotattr(a)`, donde la variable `a` es una cadena de texto con el nombre de un atributo, describe el atributo en cuestión y explica cómo especificarlo.

Cuando se especifica un atributo concreto, `plotattr` informa de varias cosas. Por ejemplo, veamos la explicación del atributo `"label"` (la etiqueta de la serie de datos para la leyenda):

```julia
plotattr("label")
```

* La primera línea da el nombre "oficial" del atributo e indica el tipo de variable que se le puede asignar (en este caso un `String`, es decir una cadena de texto).

* La segunda línea proporciona unos "alias" aceptados para referirse al atributo. Este sistema de alias está pensado para facilitar el uso a personas que ya han usado otros lenguajes de programación, ya que muchos de ellos siguen una sintaxis muy semejante entre ellos (y también semejante a la de `Plots`), pero con nombres de atributos muy variados. Los `alias` recogen algunos de los nombres de atributos usados en los lenguajes de programación más populares, de tal modo que se reduce la necesidad de aprender una nomenclatura nueva.

* A continuación viene la explicación de cómo se especifica el atributo. Cuando hay una lista de valores posibles se da una referencia completa de la misma.

* En la última línea se señala a qué tipo de componente corresponde el atributo (`label` corresponde a `Series`), y el valor por defecto.

Es conveniente destacar que no todos los atributos documentados se pueden usar con todas las librerías. La documentación de Plots incluye una serie de tablas prácticas que sirven para consultar qué opciones están disponibles según las librerías seleccionadas, http://docs.juliaplots.org/latest/supported/

Además, el valor de algunos atributos también condiciona el comportamiento de otros. El más condicionante es `seriestype`, que esencialmente define la tipología de gráfico a representar. Por defecto su valor es `:path`, que define un gráfico de líneas, pero permite muchas otras posibilidades, algunas de las cuales vamos a ver a continuación. Como se podrá observar, en función del tipo de gráfico seleccionado tendremos más o menos libertad para escoger los elementos geométricos dibujados, así como para establecer la relación de su posición, tamaño, etc. con los datos proporcionados.

Al margen de esto, jugando con los atributos y sus posibles valores podemos generar infinidad de gráficos distintos. En las siguientes secciones vamos a explorar con más detalle los distintos tipos de gráficos que podemos generar, manipulando adecuadamente los múltiples atributos disponibles, pero también a través de funciones que recogen ciertas "recetas" gráficas. 

## Gráficos de líneas y puntos

En esta categoría agrupamos un conjunto relativamente amplio de gráficos, que se caracterizan por representar los valores introducidos como coordenadas en un plano o espacio 3D; coordenadas que se visualizan por líneas que unen los puntos, símbolos que marcan su posición, o ambas cosas a la vez.

Ya hemos visto que la función `plot`, sin ningún atributo particular, crea un gráfico de este tipo en el que los puntos aparecen unidos por líneas. Pero el atributo `seriestype` nos permite crear distintas variantes: por ejemplo en la figura XXX vemos los resultados de representar los diez primeros números primos (que tenemos en la variable `diezprimos`) con las siguientes órdenes:

```julia; eval=false
plot(diezprimos, seriestype=:path)     # Gráfico de líneas (por defecto)
plot(diezprimos, seriestype=:scatter)  # Gráfico de dispersión
plot(diezprimos, seriestype=:step)     # Gráfico escalonado
plot(diezprimos, seriestype=:steppre)  # Gráfico escalonado "adelantado"
```

```julia; echo=false
p1=plot(diezprimos, seriestype=:path)
p2=plot(diezprimos, seriestype=:scatter)
p3=plot(diezprimos, seriestype=:step)
p4=plot(diezprimos, seriestype=:steppre)
plot(p1,p2,p3,p4, layout=(2,2), legend=:none, xticks=2:2:10, xlim=(0.5,10.5), ylim=(0,24))
```

[FIGURA]

Se puede destacar en primer lugar que todos los valores admitidos por el atributo `seriestype` son "símbolos" (por eso van precedidos por los dos puntos). También cabe señalar los dos tipos de gráficos escalonados recogidos: el habitual (tipo `step`) en el que de cada punto surge una línea horizontal hasta la abscisa del siguiente, y el "adelantado" (`steppre`) en el que las líneas horizontales van desde cada punto hacia el *anterior*. Por simetría, el de tipo `step` también se puede invocar con `seriestype=:steppost`. 

Para los gráficos de dispersión también tenemos una función con nombre propio, que se puede utilizar para conseguir el mismo resultado sin especificar el atributo `seriestype`, a saber:

```julia; eval=false
scatter(diezprimos)
```

La función `scatter` (y su contrapartida `scatter!` para modificar un gráfico existente) funciona igual que `plot` (y `plot!, respectivamente) en todo salvo el tipo de elementos geométricos representados por defecto. Otras funciones parcialmente redundantes son `plot3d` y `scatter3d`, que son iguales que sus análogas sin el `3d`, salvo que requieren los tres vectores de datos para las respectivas coordenadas.

### Colores de las series de datos

Entre los atributos básicos que se pueden especificar para las series de datos, el color es el más versátil, pues se puede aplicar a todos los elementos geométricos. Cuando una gráfica contiene varias series de datos (por ejemplo cuando se introduce una matriz con varias columnas, o mediante el uso de `plot!`, `scatter!`, etc.), cada serie se dibuja con un color, siguiendo una secuencia automática. Pero también se puede definir el color de forma manual. Como atributo común a todos los elementos recibe el nombre de `seriescolor` o simplemente `color`. Pero también puede definirse de forma específica:

* El color de las líneas con el atributo `linecolor`.
* El color del interior de los marcadores con `markercolor`.
* El color del contorno de los marcadores con `markerstrokecolor`.

La forma más sencilla de definir los colores es mediante sus nombres en inglés, bien en forma de cadena de texto (por ejemplo `"green"` para el color verde) o de símbolo (`:green`). El catálogo de colores que se pueden especificar es el estándar para CSS (https://www.w3.org/TR/css3-color/), que incluye 62 colores con nombre, desde los más básicos hasta algunos tan exóticos como el "blanco fantasmal" ("ghostwhite") o el de "papaya batida" ("papayawhip"). Pero incluso si ese listado no es suficiente, el estándar CSS contempla varias formas de especificar el color numéricamente. Cualquiera de las especificaciones de colores en CSS se puede expresar en Julia como una cadena de texto especial, marcada por la palabra clave `colorant`. Por ejemplo, el verde saturado (que en CSS se identifica con el color lima, "lime" en inglés), se puede expresar de las siguientes maneras:

* Como la cadena de texto `"lime"`.
* Como el símbolo `:lime`.
* Como el nombre de CSS `colorant"lime"`.
* Como el código RGB `colorant"rgb(0,255,0)"` -- también en porcentaje `colorant"rgb(0,100%,0)"`, o en código hexadecimal `colorant"#00ff00"`.
* Como el código HSL `colorant"hsl(120,100%,50%)"`.

Algunas librerías gráficas permiten definir además el nivel de opacidad (llamado "canal alfa"), que también está contemplado en el estándar CSS. Esto se especifica con el atributo `seriesalpha` (o simplemente `alpha`), que puede adoptar un número entre 0 (transparente) y 1 (totalmente opaco). También existen los atributos para elementos gráficos específicos `linealpha`, `markeralpha` y `markerstrokealpha`. Visto con un ejemplo, podríamos crear un mismo gráfico con una línea de color lima semitransparente, usando cualquiera de las siguientes instrucciones:

```julia; eval=false
plot(x,y, color=:lime, alpha=0.5)
plot(x,y, color=colorant"rgb(0,255,0,0.5)", alpha=0.5)
plot(x,y, color=colorant"hsl(120,100%,50%)", alpha=0.5)
``` 


### Otros atributos de líneas y marcadores

Al margen de los colores que hemos visto en la sección anterior, en cualquiera de los gráficos que hemos visto hasta ahora (salvo en los de dispersión donde no hay líneas), los siguientes atributos sirven para dar un aspecto personalizado a las líneas:

* `linestyle` (o simplemente `style`) para el estilo de línea. Algunos de los valores posibles son `:solid` (línea continua, que es el valor por defecto), `:dash` (a rayas), `:dot` (punteada), o `:dashdot`(línea con puntos).
* `linewidth` (o simplemente `width`) para la anchura de la línea en píxeles (un número entero).

Por otra parte en los gráficos de dispersión se puede personalizar el aspecto de los marcadores, o se pueden añadir marcadores a gráficos de otro tipo usando los siguientes atributos:

* `markershape` (o solo `shape`) para la figura del marcador. Entre otras: `:circle` (círculo; valor por defecto), `:rect` (cuadrado), `:diamond` (cuadrado girado o "diamante"), `:utriangle` (triángulo apuntando hacia arriba), `:dtriangle` (triángulo hacia abajo), `star` (estrella) `:cross` o `:+`, `:xcross` o `:x`, etc.
* `markerstrokestyle`, `markerstrokewidth`: lo mismo que en el caso de las líneas, pero en este caso aplicado al contorno de los marcadores.
* `markersize`: tamaño del marcador en términos de números de píxeles ocupado por el radio.

El atributo `markersize` también puede ser un vector de la misma longitud que la serie de datos, de tal manera que cada punto se dibuje con un tamaño de marcador determinado. De esta manera se pueden crear los llamados "gráficos de burbujas" (normalmente con marcadores redondos). Esta es una manera alternativa de añadir una tercera coordenada en gráficos planos.

Por ejemplo, podríamos tomar los resultados del análisis de datos que se hizo en el capítulo anterior, a partir de unas señales como las mostradas al inicio de este, y del que extrajimos una tabla de los tiempos y distancias entre extremos, y la proporción entre las distancias recorridas por cada coordenada. Primero cargamos esa tabla, que tenemos en el archivo "tabla.txt":

```julia
using CSV
tabla  = CSV.read("tabla.txt", delim=';')
```

Y a continuación hacemos un gráfico de burbujas en el que cruzamos estas tres variables, multiplicando el valor de `proporcionxy` por 10 para definir el radio de los marcadores en píxeles:

```julia
scatter(tabla[:tiempo], tabla[:distancia], markersize=10tabla[:proporcionxy])
```

## Gráficos de áreas y bandas

En algunos casos interesa "rellenar" el área delimitada por las líneas de un gráfico, por ejemplo cuando la integral de una señal es relevante, para dibujar una banda de datos, etc. Esto se consigue a través del atributo `fillrange`, que puede ser:

* Una serie de datos de la misma longitud que la serie principal. Esto hace que se rellene una banda que cubre el área entre las dos series de datos (no importa cuál de las dos tiene valores mayores, ni si se cruzan).

* Un valor escalar, equivalente a especificar una serie de datos con un valor fijo.

El color y la transparencia del área dibujada se heredan del atributo `seriescolor` y `seriesalpha`, respectivamente, pero se les puede dar valores específicos con los atributos `fillcolor` y `fillalpha`.

Veamos, como ejemplo sencillo, un gráfico con la banda envolvente de todas las series de datos del ejemplo. Primero hemos de calcular los límites inferior y superior de esa banda, lo cual hacemos con un bucle, como se hizo en el capítulo anterior para definir los intervalos y distancias entre máximos de las series. En este caso empleamos las funciones `min` y `max` para comparar parejas de datos:

```julia; display=false
using DelimitedFiles
directorio = "series"
archivos = readdir(directorio)
n = length(archivos)
# Tomamos la primera serie como referencia inicial
datos = readdlm(joinpath(directorio, archivos[1]))
x = datos[:,1]
limite_inferior = datos[:,2]
limite_superior = datos[:,2]
# Y luego comparamos todas las series posteriores
for i=2:n
    datos = readdlm(joinpath(directorio, archivos[i]))
    limite_inferior .= min.(limite_inferior, datos[:,2])
    limite_superior .= max.(limite_superior, datos[:,2])
end
```

Y una vez definidos los límites de la banda, en `limite_superior` y `limite_inferior`, pasamos a crear el gráfico &mdash;dándole un color negro a los límites y gris claro a la banda. Para que la línea que asignamos al atributo `fillrange` aparezca representada, también hay que dibujarla por separado (en la segunda orden con `plot!`). Además asignamos etiquetas "vacías" (`label=""`) para que no se represente ninguna leyenda:

```julia
plot(x, limite_superior, fillrange=limite_inferior,
     seriescolor=:black, fillcolor=:lightgrey, label="")
plot!(x, limite_inferior, seriescolor=:black, label="")
```

### Gráficos de barras

Los clásicos gŕaficos de barras que se extienden desde cero hasta los valores indicados por `y` se pueden crear usando `seriestype=:bar`. También existe la variante de gráficos de líneas verticales, asociada a `seriestype=:sticks` (véase la figura XXXXXX). Ambos se pueden crear también con sus propias funciones, que toman el nombre del valor del atributo (`bar` y `sticks`, respectivamente). 

```julia; eval=false
bar(diezprimos)    # Equivale a plot(diezprimos, seriestype=:bar)
sticks(diezprimos) # Equivale a plot(diezprimos, seriestype=:sticks)
```

```julia; echo=false
p1=bar(diezprimos)
p2=sticks(diezprimos)
plot(p1,p2, layout=(2,2), legend=:none)
```

Estos gráficos se usan típicamente para visualizar los valores de una tabla, de modo que el eje X se asocia a una serie de categorías, más que a una variable numérica. Por ejemplo, podríamos querer representar los datos de esperanza de vida que tenemos en la tabla del archivo `esperanzadevida.txt`:

```julia
tabla_un = readtable("esperanzadevida.txt", separator=' ')
```

Con las siguientes instrucciones podemos representar la esperanza de vida común a hombres y mujeres para cada continente. Obsérvese que el eje X no es un conjunto de valores, sino una serie de cadenas de texto:

```julia
# Usamos una variable para filtrar los casos en los que
# la columna `género` es igual a "todos"
todos = (tabla_un[:género] .== "Todos")
bar(tabla_un[todos, :continente], tabla_un[todos, :media])
```

El color de las barras y su transparencia se pueden modificar con los atributo `fillcolor` y `fillalpha`, que se definen del mismo modo que los colores de otros elementos, tal como está explicado en la sección anterior sobre los colores.

Otro atributo propio de las barras es su anchura (`bar_width`), que se mide en las unidades del eje X. Cuando no se especifica la posición de las barras en X (bien porque no se pasa el vector `x` o porque se pasa una serie de textos, como en el ejemplo anterior), `barwidth=1` dibuja barras que se tocan entre sí. Este es el comportamiento por defecto cuando se usa GR o PyPlot. Con Plotly y PlotlyJS el aspecto de las barras es fijo y el atributo `bar_width` no tiene ningún efecto.

El color y otras características del contorno de las barras se especifican con los mismos atributos que las líneas en los gráficos que hemos visto antes: `linecolor`, `linestyle`, `linewidth`, etc. De nuevo, en los gráficos de Plotly y PlotlyJS estos atributos no tienen ningún efecto sobre la estética de las barras.  

Al igual que en los gráficos de líneas y puntos, en un gráfico de barras puede interesar representar a la vez varias series de datos, dando lugar a un gráfico de barras agrupadas. Por ejemplo, en lugar de la esperanza de vida común a hombres y mujeres podríamos representar la esperanza de vida específica de cada género.

```julia; eval=false
# Alternativa 1: Añadiendo secuencialmente cada serie de datos
hombres = tabla_un[:género] .== "Hombres"
mujeres = tabla_un[:género] .== "Mujeres"
bar(tabla_un[hombres,:continente], tabla_un[hombres,:media], label="Hombres")
bar!(tabla_un[mujeres,:continente], tabla_un[mujeres,:media], label="Mujeres")
```
```julia
# Alternativa 2: Usando la columna `género` como variable de agrupación.
bar(tabla_un[!todos,:continente], tabla_un[!todos,:media], group=tabla_un[!todos,:género])
```

Sin embargo, el mecanismo para dibujar y posicionar las barras es distinto según la librería gráfica empleada, y esta forma de crear barras agrupadas solo funciona bien con Plotly y PlotlyJS. Para este y otros tipos de gráficos que requieren hacer ciertos cálculos previos con las series de datos y las medidas de los ejes, existen "recetas" que recoge el paquete [StatPlots](https://github.com/JuliaPlots/StatPlots.jl). Concretamente, la función `groupedbar` (y `groupedbar!`) sirve para este propósito particular, y se puede complementar con el atributo `bar_position`, que permite especificar si se quieren agrupar las barras una al lado de otra (`bar_position=:dodge`) o apiladas (`bar_position=:stack`).

## Otros elementos gráficos
### Barras de error

Por analogía a las bandas que podemos dibujar para representar rangos a lo largo de un conjunto contínuo de valores, también se pueden dibujar líneas verticales que representen rangos en puntos discretos del eje X, usando el atributo `yerror`. Por ejemplo, las esperanzas de vida medias presentadas en el gŕafico de barras anterior se pueden complementar con las desviaciones típicas entre países del mismo continente:

```julia
bar(tabla_un[todos, :continente], tabla_un[todos, :media],
    yerror=tabla_un[todos, :desv_tip])
```

Si queremos que las barras no sean simétricas, se puede especificar la altura por debajo y por encima de los puntos de referencia (en ese orden). Por ejemplo, si solo quisiéramos presentar la desviación típica por encima de la barra:

```julia
bar(tabla_un[todos, :continente], tabla_un[todos, :media],
    yerror=(zeros(6), tabla_un[todos, :desv_tip]))
```

## Diagramas de tarta

Los diagramas de tarta se utilizan mucho en ciertos ámbitos, y Plots también proporciona una forma de crearlos, a través del atributo `seriestype=:pie` o con la función `pie`. Por ejemplo, podemos ver la distribución de la población mundial en 2016.

```julia; echo=false
pyplot()
```

```julia
pie(["África", "América", "Asia", "Europa", "Oceanía"],
    [1216130,   1001559,  4436224, 738848,   39901])
```

La definición geométrica de este tipo de gráfico es bastante singular: la posición en el plano de los elementos geométricos tiene poca o ninguna relevancia; lo que determina el valor de cada punto es su forma, que es un sector circular de ángulo proporcional al número representado, de tal modo que el conjunto de puntos de la serie completa suman un círculo completo (360 grados).

Por lo peculiar de esta definición, las especificaciones gráficas que se pueden conseguir con otros atributos tienen poco o ningún sentido, así que Plots no proporciona de forma directa muchas posibilidades para personalizar estos gráficos.

Por otro lado, la estructura de datos que sirve de entrada a este tipo de gráfico es trivial (solo se puede representar una serie corta de datos). Así pues, los diagramas de tarta son uno de los casos en los que Julia no aporta una ventaja diferencial respecto a las hojas de cálculo y otras herramientas más comunes.

## Ejes y decoraciones del gráfico

La práctica totalidad de los atributos y recetas que hemos visto hasta ahora están relacionados con los componentes geométricos que se dibujan dentro de un gráfico, identificados como `Series` en la nomenclatura del paquete `Plots`. Pasamos ahora a ver algunas características de otros elementos del gráfico, como el plano o espacio de coordenadas que contiene esos elementos (`Axis`), el panel sobre el que se presenta dicho plano y en el que se ubican otros elementos como el título asociado al gráfico, las leyendas, etc. (`Subplot`), o la figura general (`Plot`).

Para ilustrar la configuración de estas características vamos a presentar un ejemplo que combina y decora algunos gráficos que hemos visto antes. El punto de partida es el conjunto de señales oscilatorias contenidas en XXXXXXXX, del que antes hemos usado un caso para presentar los gráficos de líneas, y el análisis de los tiempos y distancias entre los extremos de esas señales, que tenemos guardados en la variable `tabla` y hemos representado en un diagrama de dispersión. 

En `tabla` se observa que los nombres de los archivos que contienen las señales se diferencian entre los primeros 15, que empiezan por `"sA"`, y los siguientes que empiezan por `"sB"`. Vamos a representar, por lo tanto un ejemplo de cada uno de esos dos grupos de señales, para ver las diferencias; y en el diagrama de dispersión vamos a separar los resultados de ambos grupos.

```julia
# Ejemplo de serie tipo "sA"
serie_sA = readdlm(joinpath(directorio, archivos[1]))
p_sA = plot(serie_sA[:,1], serie_sA[:,2:3])
# Ejemplo de serie tipo "sB"
serie_sB = readdlm(joinpath(directorio, archivos[30]))
p_sB = plot(serie_sB[:,1], serie_sB[:,2:3])
# Juntamos las dos gráficas en horizontal, haciendo coincidir los ejes "Y"
p1 = plot(p_sA, p_sB, layout=(1,2), link=:y)
# Diagrama de dispersión (separando series "A" y "B")
p2 = scatter(tabla[1:15, :tiempo], tabla[1:15, :distancia],
             markersize=10*tabla[1:15, :proporcionxy], label="A")
scatter!(p2, tabla[16:30, :tiempo], tabla[16:30, :distancia],
             markersize=10*tabla[16:30, :proporcionxy], label="B")
             
# Decoraciones (títulos, etiquetas, leyendas...)
# Empezamos definiendo formatos
formato_titulo = font("times", 10)
formato_etiquetas = font("helvetica", :darkgray, 9)
# Al gráfico de dispersión (el último) le damos etiquetas a los ejes y la leyenda
xlabel!("Intervalo", guidefont=formato_etiquetas)
ylabel!("Distancia", guidefont=formato_etiquetas)
plot!(legend=:bottomright, legendtitle="Series", legendfont=formato_titulo)
# A los gráficos anteriores se les pone título y se le quita la leyenda
plot!(p_sA, title="serie A", titlefont=formato_titulo)
title!(p_sB, "serie B", titlefont=formato_titulo)
plot!(p1, legend=:none)
xgrid!(p1, false)

# Gráfico completo
p_completo = plot(p1, p2, layout=(2,1) size=(600,500))

```

En este ejemplo vemos instrucciones alternativas para "enriquecer" los gráficos a través de títulos, etiquetas y leyendas con formato de texto, y componiendo varios gráficos en una misma ventana. A continuación hacemos una descripción más detallada de las opciones disponibles para hacer estas y otras cosas, utilizando el ejemplo para ilustrarlas.

### Plano de coordenadas y ejes del gráfico

El elemento `Axis` identifica los ejes del plano o el espacio en los que se enmarcan los elementos geométricos. Podemos ver los atributos asociados a estos elementos con `plotattr(:Axis)`; además, la mayoría de ellos tienen variantes específicas para cada uno de los ejes (X, Y, Z), cuyo nombre es el atributo genérico precedido de la letra del eje. Por ejemplo, al atributo `guide` que identifica la etiqueta de un eje le corresponden `xguide` para el eje X, `yguide` para el eje Y, etc. Veamos en detalle estos artibutos:

**Etiquetas de los ejes**

En el ejemplo hemos empleado las funciones `xlabel!`, `ylabel!` para poner etiquentas los ejes del gráfico inferior. Además, hemos dado formato al texto de esas etiquetas añadiendo el atributo `guidefont`.

En lugar de usar esas funciones, podríamos haber pasado el atributo `guidefont` a la función `scatter` con la que se creó el gráfico (o a `scatter!`, `plot`, etc.). Y el texto de la etiqueta se habría podido pasar del mismo modo, usando los atributos `xlabel`, `ylabel` &mdash;y `zlabel`, si fuese un gráfico con tres dimensiones. (Otros alias de estos atributos son los antes mencionados `xguide`, `yguide`, `zguide`).

El formato de letra que se ha de pasar al atributo `guidefont` (o `xguidefont`, etc., si se quiere especificar solo el formato de uno de los ejes) se crea a través de la función `font`, cuyos argumentos son una serie de hasta seis parámetros que definen las distintas características del texto:

* Tipo de letra: p.ej. `"times"`, `"helvetica"`, `"courier"`, `"bookman"`, `"newcenturyschlbk"`, `"avantgarde"`, o `"palatino"`.
* Tamaño de letra: número entero que define la altura en puntos.
* Alineación horizontal: `:left` (izquierda), `:hcenter` (centrado) o `:right` (derecha).
* Alineación vertical: `:top` (superior), `:vcenter` (centrado) o `:bottom` (inferior).
* Rotación del texto: número decimal (`Float64`).
* Color, definido según las especificaciones para colores que se han comentado antes.

Estos parámetros se pueden pasar en cualquier orden, como se ha hecho en el ejemplo al definir `formato_titulo` y `formato_etiquetas`. Por ejemplo, `formato_titulo=font("times", 10)` crea un tipo de letra "Times" (de imprenta) con tamaño 10, pero también se podría haber creado con `font(10, "times")`.

Es habitual que las variables representadas en los ejes se identifiquen con letras griegas, subíndices, u otros símbolos que suelen dar problemas con algunas herramientas de creación gráficos. Respecto a este problema, la buena noticia es que Julia puede trabajar con el estándar Unicode, que comprende casi todo tipo de símbolos. Además, si el usuario está familiarizado con LaTeX, se pueden utilizar cadenas de texto del tipo `LaTeXString`, cargando previamente el paquete [LaTeXStrings](https://github.com/stevengj/LaTeXStrings.jl). Por ejemplo, si se quisiera utilizar "R<sup>2</sup>" en el eje Y, podría escribirse la siguiente línea:

```julia; eval=false
ylabel!(L"R^2")
```

La librería gráfica que da mayor soporte a los textos con LaTeX es [PGFplots](https://github.com/sisl/PGFPlots.jl). Pero entre las librerías más habituales, PyPlot también funciona muy bien para textos que no requieran paquetes de LaTeX adicionales.

**Bordes y guías**

En el ejemplo hemos anulado las guías del eje X en los gráficos superiores, mediante la orden `xgrid!(p1, false)`, donde `p1` es el conjunto de los dos gráficos (véase después sobre la agrupación de gráficos). Si hubiéramos escrito solo `xgrid(false)`, el gráfico modificado sería el último al que se ha hecho referencia.

Como ocurre en el caso de las etiquetas, además de la función función `grid!` (con sus variantes `xgrid!`, `ygrid!`...), se puede usar el atributo `grid` (`xgrid`, `ygrid`...) dentro de `plot` y otras funciones, para configuar el aspecto de la cuadrícula de guías. Los posibles valores que se pueden pasar a estas funciones o atributos son:
* `true` o `:all` para dibujar las líneas de todos los ejes
* `false`, `:off` o `:none` para ocultar la cuadrícula.
* `:x`, `:y` (o `:z` en gráficos tridimensionales) para dibujar solo las líneas de los ejes correspondientes, y combinaciones como `:xy`, `:xz`, etc.

Además, hay otros atributos para modificar el estilo de las líneas:
* `gridstyle` para definir el estilo de las líneas de la cuadrícula (sólida, punteadas, etc.), como en las líneas de datos.
* `gridlinewidth` para el grosor de las líneas.
* `gridcolor` para el color de las líneas.
* `gridalpha` para la transparencia de las líneas.

Todos estos atributos de las líneas de la cuadrícula tienen variantes específicas para cada eje (`xgridstyle`, etc.).

También podemos modificar el aspecto del borde que demarca el espacio visualizado, mediante atributos que llevan el nombre *border*, en particular (utilizando los *alias* más sencillos):

* `border` para definir qué líneas demarcan el plano o espacio dibujado. Los valores admitidos dependen de la librería gráfica. Algunos comunes son:
  + `:axes` para dibujar solo una línea de borde por cada eje (en dibujos 2D normalmente son el borde inferior y el izquierdo), de tal manera que esas líneas también sirven como representación gráfica de los ejes.
  + `:box` para dibujar "caja" completa
  + `:none` para dibujar el plano o espacio sin borde.
  + `:zerolines` para dibujar las líneas paralelas a los ejes que pasan por el origen de coordenadas, coincidan o no con el eje del gráfico.
* `bordercolor`, para definir el color del borde, del mismo modo que en los colores de los otros elementos gráficos.


**Límites y graduación de los ejes**

En el ejemplo hemos dejado que los ejes se ajusten automáticamente en función de los datos reprsentados, pero los límites y las marcas de graduación se pueden ajustar manualmente, y puede dárseles formato a través de una serie de atributos, que se describen a continuación. Salvo que se señale lo contrario, el valor por defecto de estos atributos es el símbolo `:auto`, que aplica el cálculo automático.

* `lims`: Límites del eje, que se pasan como una pareja ordenada (inferior, superior) en forma de tupla, es decir entre paréntesis.
* `ticks`: Marcas de graduación. Se especifican con un vector numérico para fijar sus posiciones en el eje; opcionalmente se puede dar una pareja (tupla) de vectores, en la que el primer vector indentifica las posiciones de las marcas, y el segundo la secuencia de textos mostrados en esas marcas (si no se quiere usar el valor numérico). 
* `scale`: "Escalado" del eje, es decir relación entre intervalos del mismo y la magnitud de los valores representados: `:none` para una aplicar una escala lineal (valor por defecto), o `:log10`, `:log2`, `:ln` para escalas logarítmicas (de base 2, 10 o neperiana, respectivamente). Este atributo también modifica las posiciones de la marca de graduación y su formato numérico.   
* `mirror`: `true` si se quieren representar las marcas de graduación en el lugar opuesto al habitual, es decir en el borde superior para el eje X, y en el borde derecho para el Y. (Por defecto este atributo adopta el valor `false`.)
* `flip`: `true` si se quiere que el eje vaya en el sentido opuesto al habitual, es decir de derecha a izquierda para el eje X, y arriba a abajo para el Y. (Por defecto este atributo adopta el valor `false`.)
* `tick_direction`: Dirección en la que se dibujan las marcas de graduación; `:in` para dibujarlas hacia el interior del gráfico (valor por defecto) y `:out` para dibujarlas hacia fuera.
* `foreground_color_axis`: Color de las marcas de graduación.
* `formatter`: Formato numérico de las marcas de graduación. Puede especificarse `:scientific` si se quiere que los números de las marcas se presenten en notación científica (p.ej. 3.5&times10<sup>2</sup>...), o pasarse una función que transforme valores numéricos en cadenas de texto, por ejemplo para forzar el número de decimales, etc.
* `tickfont`: Formato gráfico del texto presentado en las marcas de graduación. Se le asigna un objeto creado con la función `font`, como se ha explicado antes para las etiquetas de los ejes.
* `rotation`: Ángulo en grados del texto presentado en las marcas de graduación (por defecto 0 grados, es decir texto horizontal).

Estos atributos aplican por igual a los tres ejes. Para aplicarlos a un solo eje hay que utilizar las variantes "con prefijo". Por ejemplo 

```julia; eval=false
# Gráfica con el eje X limitado entre 0 y 1,
# y el eje Y en escala logarítmica.
plot(x,y, xlims=(0,1), yscale=:log10)
```

### Formato del panel gráfico

A continuación pasamos a describir los atributos que sirven para modificar el panel o lienzo sobre el que se presenta el plano de coordenadas (`Subplot`), y en el que se ubican otros elementos como el título asociado al gráfico y las leyendas. El conjunto completo de atributos asociados a este elemento se puede consultar mediante `plotattr(:Subplot)`. 

**Título**

La forma de especificar el título de una gráfica es análoga a la que se sigue para definir las etiquetas de los ejes, solo que en lugar de `label` o `guide` usamos el término `title` (y es un atributo global para todo el dibujo, que no se puede asociar a ejes específicos). En el ejemplo hemos dado títulos a los dos gráficos ubicados en la parte superior, de las dos formas alternativas que hemos comentado ya para las etiquetas:

* Mediante el atributo `title` en el caso de `plot!(p_sA, title="serie A", titlefont=formato_titulo)`.
* Con la función `title!`, en `title!(p_sB, "serie B", titlefont=formato_titulo)`.

En ambos casos se pasa primero el identificador de la gráfica a la que se aplica el título (`p_sA`, `p_sB`), porque si no el título se habría aplicado a la última gráfica, que en este caso era la del diagrama de dispersión. Además, hemos usado el atributo `titlefont` para especificar el formato del texto. Otro atributo útil es `title_location`, que controla la ubicación del título dentro del panel. Por defecto tiene el valor `:center` (título centrado), pero puede cambiarse a `:left` (izquierda) o `:right` (derecha).

**Leyenda**

Como se ha presentado al principio de este capítulo, la leyenda de las series de datos contenidas en una gráfica se crea automáticamente, con las etiquetas indicadas por el atributo `label`. En el ejemplo hemos utilizado la siguiente instrucción para modificar el aspecto de la leyenda del gráfico de dispersión, justo después de crearlo:

```julia; eval=false
plot!(legend=:bottomright, legendtitle="Series", legendfont=formato_titulo)
```

(Para asegurarnos de que modificamos la leyenda del gráfico correcto, también se puede poner como primer argumento la variable a la que se ha asignado el gráfico al crearlo, como se ha hecho con las etiquetas, guías y títulos de los gráficos superiores.)

Los atributos que se pueden utilizar para especificar las características de la leyenda son:

* `legend` para definir la posición. Dependiendo de la librería gráfica, las opciones disponibles pueden ser un subconjunto de: `:none`, `:best`, `:right`, `:left`, `:top`, `:bottom`, `:inside`, `:legend`, `:topright`, `:topleft`, `:bottomleft` o `:bottomright`.
* `legendtitle` para añadir un título a la leyenda.
* `legendfont` para especificar el tipo de letra, de forma análoga a lo presentado para etiquetas de eje y títulos.

### Cuadro de la gráfica

Habitualmente cada figura contiene un solo gráfico, por lo que no hay una clara distinción entre el elemento `Subplot` que se ha descrito antes y el cuadro general, que se identifica como `Plot`. Como en los casos anteriores, la lista completa de atributos para este elemento general se puede consultar con `plotattr(Plot)`.

Las diferencias se aprecian cuando un cuadro contiene varias gráficas, como en el ejemplo. Componer una serie de gráficas es tan sencillo como crearlas por separado, asignándolas a variables, y luego utilizar esas variables como argumentos de la misma función `plot`. Además, estas composiciones se pueden anidar, y la disposición de los gráficos controlarse mediante el atributo `layout`. Así, en la figura de ejemplo tenemos:

* Las dos gráficas superiores (`p_sA`, `p_sB`) dispuestas en una fila con dos columnas, mediante la orden: `p1 = plot(p_sA, p_sB, layout=(1,2), link=:y)`.
* La composición `p1` y la gráfica `p2` dispuestas en dos filas (una sola columna), mediante: `p_completo = plot(p1, p2, layout=(2,1) size=(600,500))`.

En estos ejemplos, la tupla de dos valores pasados a `layout` indica el número de filas y columnas de la composición, respectivamente. Para otras disposiciones más complejas se puede consultar la sección del "Layouts" del tutorial de Plots: http://docs.juliaplots.org/latest/layouts/.

El atributo `link` indica cómo se ajustan las escalas de los gráficos compuestos:

* `link=:y` (como en el ejemplo) para que los gráficos dispuestos en la misma fila tengan los mismos límites del eje vertical.
* `link=:x` para que los gráficos dispuestos en la misma columna tengan los mismos límites del eje horizontal.
* `link=:all` para que todos los gráficos de la composición tengan los mismos límites en todos los ejes. 

Por otro lado, el atributo `size` se utiliza para definir el tamaño de la gráfica en píxeles. De cara a la exportación a un archivo de imagen, también se puede utilizar el atributo `dpi` para definir su resolución (número de píxeles por pulgada).

## Guardar y gestionar figuras de gráficos

En un proyecto complejo es habitual trabajar con más de una figura. Desafortunadamente no es fácil dar una explicación sencilla sobre cómo gestionar múltiples figuras en una sesión de trabajo, porque la forma de hacerlo depende del entorno de trabajo (Juno, Jupyter, consola de comandos...) y de las características de la librería gráfica: en un extremo hay entornos con una sola ventana para mostrar todos los gráficos que se vayan componiendo (sobreescribiendo el gráfico anterior), mientras que en el otro hay entornos en los que cada pequeño cambio en un gŕáiico se presenta siempre en una ventana nueva.

Para evitar problemas, la práctica recomendada es siempre guardar los gráficos en una variable, de tal manera que se puede volver a invocar o utilizar en otro punto.

También está la cuestion de grabar la gráfica como una imagen. Para eso está la función `savefig`, que se puede utilizar como: 

```julia; eval=fasle
savefig("archivo.png")
savefig(p, "archivo.png")
``` 

La diferencia entre las dos es que en la segunda se le dice explícitamente que lo que se quiere salvar en "archivo.png" es la figura `p`. También se pueden utilizar, en lugar de `savefig`, funciones con el nombre de la extensión del gráfico &mdash;en cuyo caso no hace falta indicarla en el nombre del archivo. Por ejemplo, para salvar la figura como PNG podría haberse escrito

```julia; eval=false
png("archivo")
png(p, "archivo")
```

En el caso de querer una imagen vectorial, se podría haber salvado con la extensión SVG (para ello también existe la función `svg`, que funciona igual que `png`. Hay más formatos soportados, pero el PNG (como imagen de mapa de bits) y SVG (como imagen vectorial) son los mejor soportados por las distintas librerías gráficas.

```julia; echo=false
cd(dirbase)
Weave.restore_chunk_defaults()
```

