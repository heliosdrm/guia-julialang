### Uso del color para cualificar series de datos

Además de por su valor estético, el color se utiliza en los gráficos sobre todo por su cualidad para distinguir datos. Así pues, se puede asociar el color a una variable para utilizarlo como una dimensión gráfica más. Vemos unos ejemplos con los resultados del análisis de datos que se hizo en el capítulo anterior, a partir de unas señales como las mostradas al inicio de este. Recuperamos la tabla de resultados con los tiempos, distancias y otros parámetros que se calcularon entre los puntos extremos de las señales, y creamos un diagrama de dispersión que relaciona los tiempos de los intervalos con las distancias calculadas:

```julia
using CSV
tabla  = CSV.read("tabla.txt", delim=';')
scatter(tabla[:tiempo], tabla[:distancia])
```

Vemos que hacia la parte derecha de la gráfica los puntos parecen separarse en dos grupos. Por otro lado, en la tabla se observa que los nombres de archivo de los que proceden los datos se diferencian entre los primeros 15, que empiezan por `"sA"`, y los siguientes que empiezan por `"sB"`. Si dibujamos primero uno de los dos grupos y sobre él dibujamos el otro, por defecto cada uno de ellos se presentará con un color distinto, facilitándonos así la tarea de distiguirlos: 

```julia
scatter(tabla[1:15,2], tabla[1:15,3], label="A")
scatter!(tabla[16:30,2], tabla[16:30,3], label="B")
```

Ahora bien, hay casos en los que los datos no están agrupados en bloques, o hay muchas categorías y este procedimiento de seleccionar cada grupo y superponerlo a los anteriores es farragoso. Por ello, si tenemos una variable adicional que identifique los casos de cada grupo, esta se puede pasar al atributo `group` para hacerlo todo en una sola instrucción. Por ejemplo, con la variable `categoria` que definimos a continuación podríamos crear el mismo gráfico que antes:

```julia; eval=false
categoria = repeat(["A","B"], inner=15)
scatter(tabla[:tiempo], tabla[:distancia], group=categoria)
```

Utilizar el atributo `group` es un atajo útil en muchos casos. Su principal limitación es que solo permite agrupar por colores (que es como se distinguen las series de datos sucesivas por defecto). Haciendo la agrupación a mano, se podrían especificar otros atributos estéticos para las distintas categorías como la forma de los marcadores, el estilo de las líneas, etc.

Por otro lado, se puede utilizar el color de los marcadores para representar una variable continua, como si fuera una tercera coordenada asociada a un gradiente de color, a través del atributo `marker_z` (también llamado `zcolor`, entre otros alias). Por ejemplo, podemos apreciar que los dos grupos de datos del diagrama de dispersión anterior se corresponden con distintos rangos de la variable `proporcionxy`, representando esta variable mediante un gradiente de color:

```julia
scatter(tabla[:tiempo], tabla[:distancia], marker_z=tabla[:proporcionxy])
```

La paleta de colores que se utiliza por defecto para representar cada nuevo subconjunto de datos se puede personalizar a través del atributo `color_palette`, o simplemente `palette`. Asimismo, el gradiente de color para representar variables continuas se puede definir con el mismo atributo `colorseries` (o `color`) que se emplea para definir un color fijo. Es decir:

```julia; eval=false
scatter(x,y, group=g, palette=cp)   # Especificar la paleta para grupos de colores
scatter(x,y, marker_z=z, color=cg)  # Especificar el gradiente continuo de color
```

La paleta y el gradiente se definen mediante un vector de colores, pero la solución más sencilla es usar alguno de los gradientes de color predefinidos entre las utilidades gráficas. Hay distintas librerías de color que se pueden consultar mediante la función `clibraries`, y para cada librería la función `cgradients` da los nombres de los gradientes definidos en ellas. Por ejemplo, los gradientes definidos en la librería por defecto de Plots:

```julia
cgradients(:Plots)
```

La figura XXXX muestra algunos de los gradientes (de abajo a arriba) más distintivos que combinan dos o tres colores. Además hay múltiples gradientes monocromáticos en las distintas librerías, que reciben el nombre del color principal. A saber: `:grays` (escala de grises), `:reds` (rojos), `:greens` (verdes), `:blues` (azules), y particularmente los de la librería `:colorbrewer` que se distinguien por comenzar su nombre por mayúsculas, como `:Greys`, `:Reds`, `:Blues`, `:Greens`, más otros como `:Oranges` (naranjas) y `:Purples` (púrpuras), entre muchos más.

```julia; echo=false; eval=false
grads = [
    :inferno,
    :plasma,
    :viridis,
    :ice,
    :fire,
    :heat,
    :rainbow,
    :isolum]
scatter(1ones(25),y,marker_z=y,legend=:none,markershape=:rect,markerstrokewidth=0,markersize=40,color=grads[1])
for c=2:length(grads)
    scatter!(c*ones(25),y,marker_z=y,legend=:none,markershape=:rect,markerstrokewidth=0,markersize=40,color=grads[c])
end
plot!(xlim=(0.5,8.5),ylim=(0,0.92))
plot!(xticks=(1:8,string.(grads)), grid=false, bordercolor=:white)
plot!(yticks=([],[]))
```

Si se pasan estos gradientes al atributo `color_palette` para distinguir entre grupos, al crearse el gráfico se seleccionará automáticamente un subconjunto de colores que estén lo más separados posible entre sí.


### Anotaciones

Los puntos, barras, etc. que se dibujan en un gráfico también pueden ir acompañados de una serie de textos, que se asignan con el atributo `series_annotations` o alguno de sus alias (`text`, `texts`, `txt` y otros). Por ejemplo, podríamos añadir en forma de texto texto el valor de las esperanzas de vida del gráfico de barras anterior. Para ello aplicamos la función `string` a los valores numéricos, que se convierten en cadenas de texto (objetos de tipo `String`):

```julia
bar(tabla_un[todos, :continente], tabla_un[todos, :media],
    text=string.(tabla_un[todos, :media]))
```

A estas anotaciones se les puede dar formato utilizando la función `text`. El primer argumento de  esta función ha de ser la cadena de texto a la que se da formato, y a continuación se pueden añadir hasta seis argumentos que definen las distintas características del texto:

* Tipo de letra: p.ej. `"times"`, `"helvetica"`, `"courier"`, `"bookman"`, `"newcenturyschlbk"`, `"avantgarde"`, o `"palatino"`.
* Tamaño de letra: número entero que define la altura en puntos.
* Alineación horizontal: `:left` (izquierda), `:hcenter` (centrado) o `:right` (derecha).
* Alineación vertical: `:top` (superior), `:vcenter` (centrado) o `:bottom` (inferior).
* Rotación del texto: número decimal (`Float64`).
* Color, definido según las especificaciones para colores que se han comentado antes.

Estos parámetros se pueden añadir en cualquier orden. También se puede registrar un formato determinado con la función `font` (usando los mismos parámetros), y pasar el resultado como segundo argumento de `text`.

Por ejemplo, los textos del gráfico anterior podríamos haberlos puesto dentro de la barra variando la alineación vertical, y ajustando el tamaño y el color para mejorar la visibilidad:

```julia
etiquetas = text.(tabla_un[todos, :media], :top, 10, :white)
bar(tabla_un[todos, :continente], tabla_un[todos, :media], text=etiquetas)
```

Si quisiéramos utilizar ese formato para otros textos, la primera línea del ejemplo anterior podría haberse ampliado como:

```julia; eval=false
formato = format(:top, 10, :white)
etiquetas = text.(tabla_un[todos, :media], formato)
```

También es posible añadir anotaciones aisladas, sin asociarlas a ninguna serie de datos. Para ello se puede utilizar el atributo `annotations`, aunque es más fácil emplear la función `annotate` (o `annotate!` para añadir la anotación a un gráfico existente), que recibe tres argumentos: las coordenadas X, Y en las que se quiere colocar el texto, y el texto en cuestión, al que se le puede dar formato del mismo modo que se ha visto antes.

## Mapas de datos

Además de secuencias de valores, también podemos representar "mapas de datos" representados en una matriz numérica. Hay distintas variantes de estos gráficos, todas las cuales asocian las coordenadas del plano X-Y con las columnas y filas de la matriz, respectivamente. Los valores de la matriz, por otra parte, se representan con un gradiente de color, la coordenada Z de un gráfico tridimensional, o ambas cosas a la vez.

Tomemos como ejemplo un mapa de datos como el definido a continuación: 

```julia; eval=false
mapa = zeros(100, 100)
x=linspace(-pi,pi,100)
for i=1:100, j=1:100
    r = x[i]^2 + x[j]^2
    mapa[i,j] = exp(-r/2)*cos(r)
end
surface(x, x, mapa)
```

La última línea del código anterior, con la función `surface`, crea un "gráfico de superficie" que combina el gradiente de color y la coordenada Z como representación de los valores de la matriz. Los dos primeros argumentos de la función indican la escala que se representa en los ejes X, Y. Son opcionales, y si se omiten se utiliza una escala de números enteros que identifican las columnas y filas de la matriz.

Otras funciones para representar otro tipo de mapas (véase la figura XXXXX) son:

* `heatmap`: gráfico bidimensional, que utiliza el gradiente de color para representar los valores de la matriz. 
* `contour`: gráfico bidimenisional, con "curvas de nivel" para representar distintos valores dentro del rango de la matriz.
* `wireframe`: gráfico tridimensional, con "curvas de nivel" y líneas de gradiente.

### Forma del plano sobre el panel

`aspect_ratio` o solo `ratio`: y respecto a x. `:equal` es lo mismo que `1`. Autoajustado es `:none`.

`link`: `:none`, `:x`, `:y`, `:both` para ajustar por columnas o filas, `:all` independiente de sitio en el panel. 

`projection`: `:3d`, `:polar`, `:none`.

### Márgenes

`margin`, `right_margin`, `left_margin`, `top_margin`, `bottom_margin`. 1.0mm, también px; `:match` para los individuales.





Subplots
Asignar cada plot a una variable, y luego plot(p1, p2, ...)
Controla con el atributo `layout`, tuple.





histogram [nbins]
histogram2d [nbins]



annotate
Más bien annotate!(x,y,texto)
texto ha de ser un vector de textos tan largo como y (o x)
puede ser text(texto, atributos...)
atributos de la fuente de texto:
family: "times", "helvetica", "courier", "bookman", "newcenturyschlbk", "avantgarde", "palatino"
pointsize: Int64
halign: :left, :hcenter, :right
valing: :top, :vcenter, :bottom
rotation: Float64
color

También `colorbar`, `:none`, `:best`, `:right`, `:left`, `:top`, `:bottom` o `:legend`
`clims` para los límites de la barra.




quiver


plot(..., proj=:polar)


Stats:

density
boxplot
violin




datos = readtable(download("https://raw.githubusercontent.com/plotly/datasets/master/gapminderDataFiveYear.csv"))

datos2007 = datos[datos[:year].=2007,:]

scatter(datos2007[:gdpPercap],datos2007[:lifeExp],xscale=:log10,markersize=sqrt(datos2007[:pop]/1e6),group=datos2007[:continent],markeralpha=0.8)




